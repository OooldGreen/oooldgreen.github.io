[{"content":"这两天的晚上天气都出奇的好，刚刚好的风温柔的吹，看到很多很多的星星。\n昨天晚上，我们坐在办公楼后面的水泥地上，仰望星空，可以看到隐约的星河。我耳机里的音乐充满力量，身边的小伙伴都如此可爱。没有三脚架，我只是把小尼摊在了地上，按照小红书搜到的参数，就收获了大大的惊喜。\n极致的浪漫。\n原图直出只有放大看才明显 于是开了个灯，右上角有流星划过 8.21\n后来，又去拍了一次星星，本来还想去高速那边，不知道有没有那个机会了。\n天气晴朗，可以看到很多星星，隐约的星河，用raw拉出来之后是震撼人心的漂亮，和同事学到了一些天文知识，我真的喜欢和还单纯的这些人呆在一起，不论男女。可以算是在这里最快乐的事情了吧。\n在这里我可以看到我看到牛郎和织女隔着银河，可以看到北斗星静静地挂在天上，尽管还有那么多想看到的风景。但是现在，抬头看到星空就已经很满足，很满足了。\n快到七夕的日子，夏季大三角闪闪发光 拍到了飞机！原来是这样的啊 ","permalink":"https://oooldgreen.github.io/posts/daily/starry-sky/","summary":"这两天的晚上天气都出奇的好，刚刚好的风温柔的吹，看到很多很多的星星。\n昨天晚上，我们坐在办公楼后面的水泥地上，仰望星空，可以看到隐约的星河。我耳机里的音乐充满力量，身边的小伙伴都如此可爱。没有三脚架，我只是把小尼摊在了地上，按照小红书搜到的参数，就收获了大大的惊喜。\n极致的浪漫。\n原图直出只有放大看才明显 于是开了个灯，右上角有流星划过 8.21\n后来，又去拍了一次星星，本来还想去高速那边，不知道有没有那个机会了。\n天气晴朗，可以看到很多星星，隐约的星河，用raw拉出来之后是震撼人心的漂亮，和同事学到了一些天文知识，我真的喜欢和还单纯的这些人呆在一起，不论男女。可以算是在这里最快乐的事情了吧。\n在这里我可以看到我看到牛郎和织女隔着银河，可以看到北斗星静静地挂在天上，尽管还有那么多想看到的风景。但是现在，抬头看到星空就已经很满足，很满足了。\n快到七夕的日子，夏季大三角闪闪发光 拍到了飞机！原来是这样的啊 ","title":"Starry Sky"},{"content":"欢迎来到我的小屋～\n作为一个记性不太好的人，这个博客想要用来记录学习、成长、生活，路上的一切。\n","permalink":"https://oooldgreen.github.io/about/","summary":"欢迎来到我的小屋～\n作为一个记性不太好的人，这个博客想要用来记录学习、成长、生活，路上的一切。","title":"About"},{"content":"距离我上一次写博客竟然已经一年，总结一下这一年干了些什么吧。\n放弃 放弃博客是由于发现自己一直使用的免费域名挂掉了。我与我的博客一瞬间失去了联系，我感到无所适从。\n其实一切有迹可循。\n我关注的博主是最先丢失的。一瞬间，我们的所有联系都没有了。怅然若失。至今也不知道她是搬家了吗？搬去哪儿了？\n我才发现互联网之间的联系竟如此脆弱，数据流像茫茫大海，一叶扁舟只能随波逐流。\n忙于工作，忙于生活，忙于熬夜，忙于焦虑。忙于一切。我逐渐遗忘了这片小天地。\n尽管以往那么努力的想和互联网产生点什么联系，在工作了的那一刻，也没有了。\n我回归了一种规律又颓废的生活，离开了这篇小天地，缩回自己的壳，沉浸于另外的自娱自乐。\n寻找 这一年，我在寻找，在累积。\n日语的学习已然放弃，因为有了更远的目标——法语。看到了推特姊妹的一篇文章，感到备受鼓舞，用一年多的时候学习法语，申请语言学校，进入学徒制硕士学习，既能积攒经验又不需要太多金钱，特别适合我。于是说干就干，立马决定。后来才发现法国学徒工那么难找，我的想法那么难以实现。（当然现在也是道听途说啦，希望后面能有新的体会）\n先是雅思，津津有味，但也痛苦。最后成绩出来，考了7分，很开心，但是口语只有6，虽然知道自己不好，但也不甘心。这就像一个测试，完成自己未了的心愿，证明自己真的能学好一门语言，也是为了让自己安心，鼓励一下接下来的学习。\n接着就投入法语的学习，将近一年，从什么也不懂，听基础都费劲，到现在略摸到门道，将近一年的时间。\n学一门语言真不容易啊。\n可惜还有些后悔自己的草率和坚持。怕去了法国实在找不到学徒该怎么办。有时候心想，还不如坚持学日语，去日本至少一定能找到工作。\n唉，有时候心比天高，坚持不留东亚，又不知道哪里来的底气呢？\n新的 也不是一味学习和工作，尽管工作真的又忙又狗屁，爱玩依然是我的天性。\nCD 感谢于文文让我买了人生中第一张唱片，从此无法自拔。 沉迷于CD机发出的吱呀声响，总有些东西还在那，没变。没什么更令人心安的了。 一开始只是随便听，买一些以前听的乐队，音乐人的唱片来听，品质也不论，便宜就好了，但发现不是很喜欢。\n3月份去了邓紫棋演唱会，人生中第一次去看演唱会，特别开心。回来之后立马买了邓紫棋所有唱片里最喜欢的那张《启示录》，每次听起来都想到演唱会，又开心又感动，特别是天堂的回信，充满力量。我在狭小昏暗的寝室窝着，Gloria的歌声把我带到了一个更大的世界。后来又有了摩天动物园。买的唱片越来越符合现在的口味了。\n到现在，我有了cd机，有了蓝牙小音箱，有了装唱片的小包，我想以后去法国了就把唱片小包带着就好了，那些盒子可以珍藏在家里。希望以后有一天我有家了，给自己做个音乐角，放上我的吉他，cd机，黑胶唱片机，墙上摆满我的唱片。\n希望那一天不会特别久。\n哦对了，还有，拥有了人生中第一张黑胶唱片，也是人生中一件幸福的事，留待后面再说。\n手帐 新的一年看多了文创视频，莫名其妙开始做手帐，以前买过一些花里胡哨的贴纸文具，一是没有审美，二是实在麻烦，从来没尝试用纸做手帐。电子版就好啦，以前的我会这样想。因为反正是要走的，这些东西都是累赘。但在我心里，纸质书和电子书是不一样的，电子手帐也替代不了日记本。\n所以在这一年，我改变了想法，想要做，就从现在做，不要怕带不走，我可以慢慢带。\n现在一本tn手帐已经鼓鼓囊囊啦，第一小本已经写完了，再翻看的时候还是很开心。这样回收记忆也挺好的不是吗？和博客一样，都是独一无二的，只不过更加私人。\n2024仍然参加了Secret Santa。今年也特别开心！！！我的santa送了我25年的每周一页，和一些可爱的小印章，很用心的礼物。现在我已经用起来啦！特别喜欢，每天看着心情很好。我用它来记录我的睡眠、饮食、心情和一日一句（活或者两三句吧），碎碎念记录在tn本里，觉得这个配置很圆满，又精简又实用。已经在期待年末的时候回看这一本小册子啦！希望快快带她到另一个国家，记录新的生活。而我作为santa，送给别人的礼物是一副我自己很喜欢的塔罗牌，了解到对方是很资深的塔罗师，所以按照对方的喜好和论坛的蛛丝马迹下单了这副牌，尽管送出去之前也有很多的不安和顾虑，万幸的是对方很喜欢！她说是第一副这么可爱的牌哈哈，并且愿意送我一次塔罗占卜，但是很i的我根本不敢相认！\n可爱的本本和印章 也是因为做了这么多塔罗功课，才成就了第四项新的喜好——塔罗。\n从尚雯婕到李霄云 浪姐5让我了解爱上了尚雯婕。\n恰逢刚刚开始学法语的痛苦时期，一个复旦法语系的学霸多有激励作用自不必多说。以前只知道她的执拗，却不知道在执拗什么，从一档综艺衍生出的诸多好奇驱使我看见。看见她的从前，她的优秀，她的追求，她的理想，她的真诚，她的努力，她的痛苦，她的别扭和小可爱。也看见了她的音乐，从in得来痛苦又黑暗的共鸣，因我适逢人生中痛苦的阶段，被迫来了不想进的公司，没有节假日的痛苦，刚开始工作出了很多不严谨的错误，许多尚雯婕的痛苦发泄，于我竟也是一种发泄。我开始尝试了解那些之前不愿意听的怪奇音乐，我发现音色如此多样，甚至人的嗓音也只是一种乐器。我发现了主旋律之外不和谐的美，这让我感到惊喜和快乐。我开始理解她的理想抱负和纯粹坚持，并相信人应该为理想奋斗一生。以她为标杆，我也能一直坚持着。\n音乐又一次向我敞开了一扇不同的大门。\n这世界有音乐真好啊。我无数次情不自禁的想。\n接着就是时光音乐会与李霄云的结缘。为尚雯婕而来，却认识了这个彻头彻尾的理想家。如果说尚雯婕是理想现实家，李霄云就只有理想。哈哈哈。 但我那么喜欢，纯粹真诚的人，永远吸引我。\n那一抹蓝色就成了我9-12月最亮眼的色彩，从认识，到考古，到了解，到找到还剩下的不多的云团，大家出于对一个人的欣赏而聚集在一起，我做了一些疯狂的事情，也收获了许多善意。\n和尚雯婕一样，李霄云的唱片也越来越在做自己。但不同的是，更加纯粹。我在售罄之前买到了人生中第一张黑胶唱片《浪漫 病》，艺术的蓝色封面，简单的配图，我很期待，拥有唱片机的时刻，它能够释放出光彩。在此之前，我还收到了老团团出给我的签名版《三十禁》，至今我还没有舍得拆开，但我会的。因为里面还有艺术家精心准备的丑画等一系列设计。我要去感受，我不能辜负一份用心的作品，也要让物品发挥它的价值。\n12月，从来没想到能去北京见到李霄云。 是一年一度的约定，蓝色圣诞节。对于刚认识李霄云不久的我是一种出乎意料的惊喜，同时也是害怕。尽管在此之前我已经托别人送过一封信给她（鼓起莫大的勇气，给陌生人写不会收到回信的信！！！但我要表达我的支持，对于她的音乐梦想，那也是我的灯塔）。那是疯狂的一周，我花了一周的时间做了许多的小设计，做成了二十几份物料包，这也是我人生第一次做物料。 多么神奇，我喜欢做设计，就让我在这件事上过了把瘾。以前也设计过手幅和海报，但从不敢想象做成成品是什么样子。不知道出于什么样的勇气，我做了这次尝试。我设计了三款明信片（有一张印刷效果实在不理想），一张入场券，两张表情包贴纸，一张背卡，配上诸如nfc钥匙扣，反转胶片的小玩意儿（我都是第一次听说），从包装到贴纸到内容物印刷，有两个夜晚，我通宵度过，第二天还要照常去上班，但我感到很快乐。这也让我更迷茫，怎样才能做我想做的事，过这样快乐的生活呢？此时我的课题还是这一个：如何通过我喜欢的事情赚到钱呢？\n反馈也是很好的，尽管发的时候慌慌张张很不好意思，但也收到了一些交换和感谢和夸奖。我想明年做更有巧思的礼物带去蓝蛋，却觉得没有机会了。也许以后安定下来，每一年，都在圣诞准时来北京赴约吧。\n像素风谐音梗贴纸梨笑云（李霄云） 超级喜欢这种有小设计又简约的背卡嘿嘿，很喜欢谐音梗设计 三组明信片，三个不同的风格，有很多寓意，比如叠图了霄云拍摄的景色呀，大蓝开到彩虹里呀，小狗sam陪你过蓝蛋呀等等 私心做了很酷有点魔幻的纪念票，可惜字体有点太亮画面太暗，没有时间修改 蓝蛋也是值得说道的独家回忆呢！第一次见到一个明星，才知道明星比镜头里瘦这么多！第一次见到一个明星泣不成声（因为我们的礼物哈哈哈），自己都觉得自己没面子了。小表演环节，小乐队表演特别喜欢，有偷偷录音～有可爱的小游戏做，知道答案的我都畏畏缩缩不敢举手呢，所以没得到特别礼物\u0026hellip;旁边的姐妹也是超级大i人，她送了我的画像（一分钟丑画）给我，我却至今不知道她是谁呢哈哈。和李霄云合影，手忙脚乱的签名，一句话也说不出，还要李霄云自己搭话哈哈，她写名字的时候很认真，一笔一画，偷偷瞄我的动作来模仿拍照，很可爱。工作室小伙伴zam有帮我录像，一百多个人唉！人好有耐心好nice。和吵吵闹闹的新团团一起去吃海底捞，和超级厉害的设计学博士（画画超级好看）同屋，聊喜欢李霄云的理由，聊自己的精神理想到半夜，和另一个团团结伴去看天安门广场升国旗，国旗升起来的时候，太阳也升起来了，人民大会堂闪耀着橘粉色的光，本该是威严的殿堂也梦幻了起来呢。手脚冻得僵硬的我还捡到了手机，还给她的主人。一切都那么完美。\n珍贵的大合照 凌晨三点的海底捞聚餐 粉色的人民大会堂 去机场的地铁上我打开了李霄云的十周年蓝蛋礼物——一瓶定制香水，好闻的木质香气萦绕在耳边，地铁晃晃悠悠，光秃秃的树木像后方倒去，阳光穿透玻璃照进来，暖气开得足足的，我因为太困了有点晕乎乎，我想我愿意一直这么开下去。\n当然也出现了一些尴尬事件，丢了身份证什么的。也算是让我安心啦，一直这么幸福可怎么办呀。\n回来之后李霄云又在直播间一个个拆礼物，拆到我的礼物的时候我好紧张，是阿勒颇古皂，非常实用的物品，希望她会用（可能她也不会吧，哪能乱用陌生人的东西呢？），信件和一些小物料，关于她的照片，和我设计的小东西。李霄云和云团像朋友一样，也许就这样一辈子互相陪伴下去了吧。毕竟李霄云也是要唱一辈子的人呢。\n满满当当的礼物～圣诞节苹果超甜 塔罗 蓝蛋回来之后颇用了几天平复心情呢。听小表演的录音，和团团聊天，也期待我的设计巧思被看见（虽然并没有），这个东西一定要自己说！可是我还是别扭又胆小，没有那么多勇气。\n于是我开始了研究礼物阶段就感兴趣的塔罗，目前还停留在看看玩的阶段，学习法语之余看一看，蛮有意思的～也能给我一些人生的思考。\n旧的 旅行 今年仍然偷跑出去旅游，去云南一周，经过了昆明、大理、丽江、香格里拉，和家人们度过了又累又充实的一周，有机会真想在大理住下，终于理解了网红博主们为啥这么喜欢这个地方～但最喜欢的还是香格里拉的两天，喜欢自然风光，第一次看到那么完整的日晕（好漂亮！（但是有点高反啦～）\n工作 在这个地方工作正式满一年啦，每天骂骂咧咧，做一些狗屁工作，但也从狭窄逼仄的寝室搬到了几乎算是单人寝室的大一点的房间，于是开始了每天自己鼓捣鼓捣的新生活。\n摸摸鱼，学学习，能不上班就不上班！\n学习 学习语言也一年多啦，从英语换到法语，甚至中间也找过老师，在天坛的时候还因为旁边听到有法国人在给同伴介绍天坛激动的跳起来，对世界好奇！以后还想学更多语言，德语，西班牙语，日语，终身学习。\n健康 2924年因为拔牙、补牙、生病打吊针花了好多钱，万幸智齿拔光光啦！牙齿补好了，身体也恢复了，以后要更关注自己的身体！\n小结 2024年热爱这个世界的部分：音乐，音乐永远不会辜负我；美景，一眼难忘，我仍然想念青海；美食，唯有美食不可辜负；画，什么时候可以用来表达我的心灵！；人们的善意，我如此害怕被抛弃\u0026hellip;\n2024也有很多很多的第一次：第一次看演唱会，第一次去云南，第一次去到海拔五千多米的地方（玉龙雪山），第一次看到日晕，第一次拥有黑胶唱片，第一次开始做手帐，第一次收到需要拼的八音盒礼物，第一次把自己的设计变成实物，第一次参加明星线下见面会，第一次看升国旗\u0026hellip;\n2024是我工作的第一年，工作教我细心了很多，谨慎了很多，现实了很多，但是我的理想主义和许多思考仍然在继续。我对国家，对世界，对个人，都仍有许多感悟。对自己感悟最深的就是不管怎样选择都是自己承担责任，没有完美的选择，懦弱并不能解决问题，所以新的一年，我决心站起来主动向前走，而不是被一切推着走，这样，我才有可能主宰自己人生的方向。这些男孩子一早就学会的东西，我却花了如此长的岁月说服自己，当然也受到了教训。\n我仍然热爱这个世界，不完美，匪夷所思，但有那些星星点点的灯塔照亮我前行就够了，也许有一天，我也能成为别人的灯塔？谁知道呢。\n跨年的时候，和同事们去吃了火锅，买了小啤酒，急匆匆回屋喝酒写2024年终总结，看跨年表演，还收到了李霄云的可爱跨年祝福！37岁的人了像个孩子一样，怎么这么可爱！（其实也是我想活成的样子啦），收到了球会的跨年可爱漫画红包，收到了一些新年祝福（很少，但我已经不太需要了），开启了我的一周一页，贴好了我的年历，拼好了朋友送我的樱花树八音盒，过了一个仪式感满满的跨年。\n开始相信自己真的可以做成一些事情 现在已经是新的一年啦！于是我又一次心血来潮重启自己的博客，颇为此花费了一些精力，知识都快忘完啦，又要复健，又要不停谷歌，神奇的是一些指令还在我的潜意识里游玩。\n看了塔罗占卜，都说今年也是奋斗也是相对顺遂的一年，而且是奋斗了就会有结果！结果要在明年的时候来显现，感觉完美对应上了我的规划时间线，希望一切顺利！\n现在我常觉羞耻和软弱，就是因为我没能说自己想说的话，做自己想做的事，太在意别人的看法，反而委屈了自己。我在重新养育自己，不苛待自己，尝试倾听自己内心的声音，希望有一天我也能遵从本心，成为让自己骄傲的人。\n","permalink":"https://oooldgreen.github.io/posts/daily/review2024/","summary":"\u003cp\u003e距离我上一次写博客竟然已经一年，总结一下这一年干了些什么吧。\u003c/p\u003e","title":"新年好，2025"},{"content":"一直想了解一下国家近百年的历史，一直拖着。 英文书实在读不下去了，便终于打开了这篇。\n惊心动魄的一百年，普通人在其中沉浮，挣扎，如一粒尘埃，被历史的车轮碾过；如一枚浪花，在历史的洪流中起起伏伏，被拍打在沙滩上。\n惨绝人寰的夹边沟农场，风起云涌的敦煌研究院，突如其来的监狱之行。 多少人的青春乃至生命，埋葬在戈壁滩、盐碱地，消逝在无意义的互相揭发和批斗。\n岁月虽苦，作品中也不乏乐趣，小时在山中躲得一时宁静，借着画大画脱离苦海，在敦煌洞窟中获得禅意，远离世俗喧嚣。\n虽有片刻宁静，世事终不放过敢于直言之人。不管他的言论是对是错，那时他却连表达自己的权利都被剥夺。不仅如此，还要受尽皮肉之苦，叫人闭嘴；压迫人的神经，让人变成行尸走肉，一具供人操控的躯壳，嘴里喊着的都是别人叫她喊的，心里想的都是别人叫她想的。至于这个别人是谁？那群权力最大之人又凭何权力最大？普通人生存尚且困难哪有时间思考。\n不吃这一套的人，就没有生存的余地了。 所以最后作者也远走他乡，一辈子只能在书中写家园，梦家园，一辈子也回不来。他的一切贡献，永远的被埋没在这片土地。如同高耀洁老师一样，人们谈起来只会说她偏激，总有贡献也是可惜。\n读书时跨越时空也能感同身受，说来可笑，心中不时一番兔死狐悲之感。\n总觉得现在的生活也似在监狱之中，越来越严格的审查让人不敢说什么真话，遑论言论自由！众口一词，普通的人民并不需要灵魂。 小环境也如此，勾心斗角，波谲云诡，多的是我看不懂的阴暗人心。\n这本书看过也便看过来，告诫自己这样的书不可多看，生出一股无力感，又如何向上拼搏离开此处？\n希望十年以后，我再打开此书，呼吸的已是新鲜的空气，再读的心境也会迥然不同吧。\n","permalink":"https://oooldgreen.github.io/posts/archive/xunzhaojiayuan/","summary":"一直想了解一下国家近百年的历史，一直拖着。 英文书实在读不下去了，便终于打开了这篇。\n惊心动魄的一百年，普通人在其中沉浮，挣扎，如一粒尘埃，被历史的车轮碾过；如一枚浪花，在历史的洪流中起起伏伏，被拍打在沙滩上。\n惨绝人寰的夹边沟农场，风起云涌的敦煌研究院，突如其来的监狱之行。 多少人的青春乃至生命，埋葬在戈壁滩、盐碱地，消逝在无意义的互相揭发和批斗。\n岁月虽苦，作品中也不乏乐趣，小时在山中躲得一时宁静，借着画大画脱离苦海，在敦煌洞窟中获得禅意，远离世俗喧嚣。\n虽有片刻宁静，世事终不放过敢于直言之人。不管他的言论是对是错，那时他却连表达自己的权利都被剥夺。不仅如此，还要受尽皮肉之苦，叫人闭嘴；压迫人的神经，让人变成行尸走肉，一具供人操控的躯壳，嘴里喊着的都是别人叫她喊的，心里想的都是别人叫她想的。至于这个别人是谁？那群权力最大之人又凭何权力最大？普通人生存尚且困难哪有时间思考。\n不吃这一套的人，就没有生存的余地了。 所以最后作者也远走他乡，一辈子只能在书中写家园，梦家园，一辈子也回不来。他的一切贡献，永远的被埋没在这片土地。如同高耀洁老师一样，人们谈起来只会说她偏激，总有贡献也是可惜。\n读书时跨越时空也能感同身受，说来可笑，心中不时一番兔死狐悲之感。\n总觉得现在的生活也似在监狱之中，越来越严格的审查让人不敢说什么真话，遑论言论自由！众口一词，普通的人民并不需要灵魂。 小环境也如此，勾心斗角，波谲云诡，多的是我看不懂的阴暗人心。\n这本书看过也便看过来，告诫自己这样的书不可多看，生出一股无力感，又如何向上拼搏离开此处？\n希望十年以后，我再打开此书，呼吸的已是新鲜的空气，再读的心境也会迥然不同吧。","title":"《寻找家园》"},{"content":"她的离去，让我又认识了一段在这片土地已被埋葬的历史。\n彼时，距离她的逝世，已过了一月有余。\n彼时，我刚看完了李莲花。这本从小躺在我的电子书单中的书。一边内心吐槽作者不要太爱男，一边沉迷电视剧无法自拔，随着多巴胺的瘾，下坠。\n在不明白博客早已听了这集播客，失落于没有即时的多巴胺给予我刺激，打开了久违的油管，先看了两集喜欢的家居博主，才打开了柴静账号上传的纪录片《中原纪事》。\n果然，视频给人最直接的刺激。\n恰逢在看高尔泰《寻找家园》，对于那近一百年的血泪史，不胜唏嘘。\n整部纪录片，都是我记忆中还的村庄、土路、麦田、麦田中的坟头。那毕竟是河南。如此近的距离，还不足以改变风俗和风貌，一切都那么熟悉。\n我知道，河南承受了太多，许许多多的人在这片土地上出生又死亡。有时候我会想都这么穷了为什么还要生孩子？到底还有什么骄傲的基因值得延续？他们穷到去卖血，为了养家糊口，抱着日子能好过一点的想法，也没想过卖血会把命都卖进去。\n上访，被恐吓，被监视，拿不到免费药物和补助，买假药，受病痛折磨。\n曾经“感动中国”的人物高耀洁远走他乡，与家人分离。\n一场血祸，多少家庭的破灭。如今，多数人已死，等他们都死了，这件事便被彻底遗忘。就像64，这代人死了，便没人记得。一些人，得以继续高枕无忧。\n高耀洁离开了，高尔泰离开了，千千万万敢于说真话的人离开了，剩下的人，终于，将眼睛闭了起来。\n真的都闭起来了吗？ 未必。\n纪录片的最后，一首大悲咒，祭奠所有往生人。\n","permalink":"https://oooldgreen.github.io/posts/daily/gaoyaojie/","summary":"\u003cp\u003e她的离去，让我又认识了一段在这片土地已被埋葬的历史。\u003c/p\u003e","title":"高耀洁"},{"content":"不知不觉一个月过去了，离我在官亭每日看星星的日子仿佛已经过去了很久很久。\n还记得走的那一天，云山雾罩，难得潮湿的空气，是清爽的早晨。\n我的行李只剩粉色箱子和黑色背包，还有心爱的相机。\n冲冲帮我提箱子，提到楼底下，我跟刘姐说，要走啦。我竟然从她的眼中看到某种不舍。然后被掩饰过去，一切如常。我不知道是我的错觉，还是她很错愕我的道别，又或是被这突然的离别惊到，夹杂着的不舍。\n我看着山，我看了两个月的山，终于走到了山脚下。走近看山更像是在云里埋着了。山的另一边，仍然是一样的景色。\n在出租车上我偷偷在掉眼泪，我想我已经多年没有如此深刻涌动的情感，无法抑制，没有理智。我在悲观的想可能再也不会有如此快乐的时光。\n不记得几天之前了，我还去高速上看了星星，带着相机，三脚架，但其实一张也没拍。我有点尴尬，一直在讲话，说那些有的没的，一边说抬眼看着星空。\n那天的星星格外的多，不愧是小程序上97%观星指数的好天气。肉眼可以看到的银河，app上可以辨别出璀璨的星座。我站在高速的岔路口上，脚下是沥青的路面，不远处是滋滋作响的超高压点。我在世间如此渺小。\n我只有一个感受，真浪漫啊。宇宙妈妈给我的究极的浪漫。\n我想我终于又有一个记忆，可以用来刷新多年前四川乡村看到的星空。尽管星空如此美丽，但我仍然认为那个记忆并不太好，夹杂了一些过于沉重的东西。\n然后就是旅行，玩耍，吃吃喝喝。城市的生活如此的意料之中，我感觉我彻底进入了自己的领域，已经完全习惯的一种生活。我表现的和以前一样，一个正常的城市里的小孩。可我总在想的是在官亭的时候，日子是怎样怎样的。我抬头看的时候，天空是城市的反光，星星寥寥落落几颗。\n尽管在城市里，我仍然在想，有一天我还会去看的，星空，极光，旷野。\n新的环境，新的部门，新的同事，新的生活秩序。\n很多很多的不习惯，很多很多的不开心。就在昨天，我在日记上写道：哎，此事难两全。但是我有新的东西要学习，新同事挺好的，办公室氛围也还不错，也有了新的目标。想念的小伙伴也已经有了新的生活。\n努力捱着，带着梦想，有些牵挂的东西慢慢清理。终有一天，也许我还没准备好，但我已准备好。\n","permalink":"https://oooldgreen.github.io/posts/daily/journal231015/","summary":"不知不觉一个月过去了，离我在官亭每日看星星的日子仿佛已经过去了很久很久。\n还记得走的那一天，云山雾罩，难得潮湿的空气，是清爽的早晨。\n我的行李只剩粉色箱子和黑色背包，还有心爱的相机。\n冲冲帮我提箱子，提到楼底下，我跟刘姐说，要走啦。我竟然从她的眼中看到某种不舍。然后被掩饰过去，一切如常。我不知道是我的错觉，还是她很错愕我的道别，又或是被这突然的离别惊到，夹杂着的不舍。\n我看着山，我看了两个月的山，终于走到了山脚下。走近看山更像是在云里埋着了。山的另一边，仍然是一样的景色。\n在出租车上我偷偷在掉眼泪，我想我已经多年没有如此深刻涌动的情感，无法抑制，没有理智。我在悲观的想可能再也不会有如此快乐的时光。\n不记得几天之前了，我还去高速上看了星星，带着相机，三脚架，但其实一张也没拍。我有点尴尬，一直在讲话，说那些有的没的，一边说抬眼看着星空。\n那天的星星格外的多，不愧是小程序上97%观星指数的好天气。肉眼可以看到的银河，app上可以辨别出璀璨的星座。我站在高速的岔路口上，脚下是沥青的路面，不远处是滋滋作响的超高压点。我在世间如此渺小。\n我只有一个感受，真浪漫啊。宇宙妈妈给我的究极的浪漫。\n我想我终于又有一个记忆，可以用来刷新多年前四川乡村看到的星空。尽管星空如此美丽，但我仍然认为那个记忆并不太好，夹杂了一些过于沉重的东西。\n然后就是旅行，玩耍，吃吃喝喝。城市的生活如此的意料之中，我感觉我彻底进入了自己的领域，已经完全习惯的一种生活。我表现的和以前一样，一个正常的城市里的小孩。可我总在想的是在官亭的时候，日子是怎样怎样的。我抬头看的时候，天空是城市的反光，星星寥寥落落几颗。\n尽管在城市里，我仍然在想，有一天我还会去看的，星空，极光，旷野。\n新的环境，新的部门，新的同事，新的生活秩序。\n很多很多的不习惯，很多很多的不开心。就在昨天，我在日记上写道：哎，此事难两全。但是我有新的东西要学习，新同事挺好的，办公室氛围也还不错，也有了新的目标。想念的小伙伴也已经有了新的生活。\n努力捱着，带着梦想，有些牵挂的东西慢慢清理。终有一天，也许我还没准备好，但我已准备好。","title":"十月随想"},{"content":"句型 肯定句 主宾谓： 私は　マイク・ミラーです。\n否定句 サントスさんは　学生 じゃありません。\n疑问句 助词か表示疑问，读升调\nミラーさんは　会社員　ですが。\n肯定回答：はい、會社員です。 否定回答：いいえ、学生じゃありません。 询问要做什么的疑问句\n疑问词 どんな　什么样的 5W 何の　有关什么的，表示内容 どうして　为什么 eg: どうして　日本語を　勉強しますか。 誰（だれ）　谁，哪位 どこ 哪里 いつ 什么时候 选择疑问句 — それは　ボールです ですか、シャープペンシル　ですか。\n— ボールペンです。\n有动词的句式 肯定形 否定形 现在形 〜ます 〜ません 过去形 〜ました 〜ませんでした 现在肯定：私は　毎朝　六時に　起きます。 过去肯定：私は　昨日　勉強しました。 勉強します\n勉強しました\n勉強しません\n勉強しませんでした\n全否定句 — 今朝　どこへ　行きましたか。\n— どこ　「へ」も　行きませんでした。 哪里也没有去。\n邀请 否定型 + か、〜ませんか，邀请别人做某事，更为尊重\n— 一緒に　神戸へ　行きませんか。 要一起去神户吗？\n— 肯定回答：ええ、行きましょう。 好，去看吧。\n— 否定回答：すむません、ちょっと\u0026hellip;\n〜ましょう，积极的邀请，提议\nちょっと　休みましょう。 休息一下吧\n終わりましょう 结束吧\n助词 も 助词，也，表示同前\nサントスさんも　会社員です。\nの 表示属性\n私は　IMCの社員です。\n表示所产\n疑问使用「どこ/どちら」询问，后者更为郑重\n— これは　どこ車ですか。\n— これは　日本の車です。\n表示内容\n— これは　何の本ですか。　这本书内容是什么？\n— カメラの本です。　关于相机的书\nに 表示动作进行的时间点\n私は　六時に　起きます。\n私は　7月15日に　国へ　帰ります。\n表示动作的到达点\n私は　学校に　行きます。\n表示接触点\n友達に会います 和朋友碰面，见面\n表示动作的对方\n私は　木村さんに　花を　あげます。　我送花给木村小姐。\nから（只有当前面是施（授）方的时候可以使用，前面的授方是组织的情况只用から）：\n私は　カリナさんから　チョコレートを　もらいました。\n私は　銀行から　お金を　借りました。\nと 表示并列关系\n休みは　土曜日　と　日曜日　です。\n表示动作伙伴，“跟”\n私は　家族と　日本へ　きました。\nから 表示起点，和まで一起使用\n私は　九時から五時まで働きます。\n要用于继续性动作，不能用于瞬间性的动作\n例如：終わります，只能使用「に」\n因为、所以，表示原因\n今日は　子供の　誕生日ですから、早く　帰ります。\n表示动作的对方（见に）\n只有当前面是施（授）方的时候可以使用，前面的授方是组织的情况只用から\n私は　カリナさんから　チョコレートを　もらいました。\n私は　銀行から　お金を　借りました。\nまで 表示终点，和から一起使用\n昼休みは　十二時から一時までです。\nへ 做助词的时候读え（e），表示移动的方向\n私は　は　京都へ　行きます。(へ　に 都是对的)\nで 表示交通工具\n私は　タクシーで　うちへ　帰ります。\n步行是动作，不算交通工具\n私は　歩いて　学校へ　行きます。\n表示动作进行单位\n私は　一人で　学校へ　来ました。\n表示动作进行地点\n私は　駅で　新聞を　買います。\n表示方法、手段\n私は　バソコンで　映画を　見ます。　用电脑看\nこれは　日本語で　何ですか。　这个用日语怎么说？\n我有～，一般表示我有什么事情\n約束が　あります。 有约会\n东西一般用を\n約私は　車を　持っています。\nを 表示动作作用对象（把）\n私は　本を　読みます。\n水を　飲みます\nテレビを 見ます\nたぼこを　吸います\n我有～，一般表示我有什么东西\n私は　車を　持っています。\n事情一般用が　約束が　あります。\nが 表示逆接，但是，不过\n高い　ですが、いいです。　很贵但很好\n表示焦点\n私は　イタリア料理か　好きです。 我喜欢意大利料理。\n私は　日本語を　勉強します。 动词，表示动作，用把\n私は　日本語が　わかります。　动词，非动作，用焦点\n指示词 单独 接名词 近自己 これ この 近对方 それ その 远方 あれ あの これは　辞書です。 はい、それは　辞書です。 指事物 指地方 指事物、地方、人（郑重/口语） 这（那）样 这（那）样的 近自己（こ） これ この ここ こちら/こっち こう こんな〜 近对方（そ） それ その そこ そちら/そっち そう そんな〜 远方（あ） あれ あの あそこ あちら/あっち ああ あんな〜 疑问句（ど） どれ どの どこ どちら/どっち どう どんな〜 数字表达 歳(さい) テレーザ　ちゃん　は　９歳です。\nちゃん：对小孩的称呼 岁数： １歳 いっさい ６歳 ろくさい ２歳 にさい ７歳 ななさい ３歳 さんさい ８歳 はっさい ４歳 よんさい ９歳 きゅうさい ５歳 ごさい １０歳 じゅっさい ２０歳 にじゅうさい　/　はたち 价钱 询问价钱「いくら」\nこの　ネクタイは　いくら ですか。 货币 日元 — 円（えん）\n人民币 — 元（げん）\n美金 — ドル\n港元 — 香港ドル（ホンコン）\n欧元 — ユーロ\n数字 万 千 百 十 一 1 いちまん せん ひゃく じゅう いち 2 にまん にせん にひゃく にじゅう に 3 さんまん さんぜん さんびゃく さんじゅう さん 4 よんまん よんせん よんひゃく よんじゅう よえん/よんげん 5 ごまん ごせん ごひゃく ごじゅう ご 6 るくまん ろくせん ろっびゃく ろくじゅう ろく 7 ななまん ななせん ななひゃく ななじゅう なな 8 はちまん ほっせん はっびゃく はちじゅう はち 9 きゅうまん きゅうせん きゅうひゃく きゅうじゅう きゅう 360日元：さんびゃく　ろくじゅう　円\n306日元：さんびゃく　ろく　円\n78604日元：ななまん　はっせん　ろっびゃく　よえん\n描述时间 时 分 1 いちじ いっふん 2 にじ にふん 3 さんじ さんぷん 4 よじ よんぷん 5 ごじ ごふん 6 るくじ ろっぷん 7 しちじ ななふん 8 はちじ はっぷん 9 くじ きゅうふん 10 じゅうじ じゅっぷん/じっぷん 11 じゅういちじ 12 じゅうにじ 30 はん 几点几分：何時（なんじ）何分（なんぷん）\n星期 月火水木金土日\n月曜日　ー　げつようび 火曜日　ー　かようび 水曜日　ー　すいようび 木曜日　ー　もくようび 金曜日　ー　きんようび 土曜日　ー　どようび 日曜日　ー　にちようび 何曜日　ー　なんようび\n年月日 いつ　- 哪一天，询问时间\nいつ　日本へ　来ましたか。　３月２５日に　来ました。\n誕生日は　いつですか。　6月１３日です。\n月份 1月 - いちがつ\n2月 - にがつ\n3月 - さんがつ\n4月 - しがつ\n5月 - ごがつ\n6月 - ろくがつ\n7月 - しちがつ\n8月 - はちがつ\n9月 - くがつ\n10月 - じゅうがつ\n11月 - じゅういちがつ\n12月 -　じゅうにがつ\n日期 1日 - ついたち\n2日 - ふつか\n3日 - みっか\n4日 - よっか\n5日 - いつか\n6日 - むいか\n7日 - なのか\n8日 - ようか\n9日 - ここのか\n10日 - とおか\n14日 - じゅうよっか\n20日 - はつか\n24日 - にじゅうよっか\n其他：〜日（にち）\n17/27 - しち\n19/29 - く\n私は　7月15日に　国へ　帰ります。\n接续词 それから　然后\nうちで　宿題を　します。それから　CDを　聞きます。\nそして　而且\n便利です。そして　綺麗です。 很方便，而且很干净\n副词 ときどき　有时候\nもう　已经 私は　もう　メールを　送りました。\nー　もう　昼ご飯を　食べました。\nー　はい、もう食べました。\nー　いいえ、まだです。 还没\n形容词 肯定形 否定形 名词 学生です 学生じゃありません な形容词 綺麗です 綺麗じゃありません い形容词 高いです 高くないです いいです 好 -\u0026gt; 否定形 -\u0026gt; よくないです　不好\nな形容词后接名词用「な」、い形容词后直接接名词\nな形容词 桜は　きれいです。\n桜は　綺麗な 花です。\n好きです\n嫌いです\nい形容词 い形容词都是「い」结尾\n富士山は　高い　山です。\n","permalink":"https://oooldgreen.github.io/posts/language/%E3%81%BF%E3%82%93%E3%81%AA%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E/","summary":"句型 肯定句 主宾谓： 私は　マイク・ミラーです。\n否定句 サントスさんは　学生 じゃありません。\n疑问句 助词か表示疑问，读升调\nミラーさんは　会社員　ですが。\n肯定回答：はい、會社員です。 否定回答：いいえ、学生じゃありません。 询问要做什么的疑问句\n疑问词 どんな　什么样的 5W 何の　有关什么的，表示内容 どうして　为什么 eg: どうして　日本語を　勉強しますか。 誰（だれ）　谁，哪位 どこ 哪里 いつ 什么时候 选择疑问句 — それは　ボールです ですか、シャープペンシル　ですか。\n— ボールペンです。\n有动词的句式 肯定形 否定形 现在形 〜ます 〜ません 过去形 〜ました 〜ませんでした 现在肯定：私は　毎朝　六時に　起きます。 过去肯定：私は　昨日　勉強しました。 勉強します\n勉強しました\n勉強しません\n勉強しませんでした\n全否定句 — 今朝　どこへ　行きましたか。\n— どこ　「へ」も　行きませんでした。 哪里也没有去。","title":"みんなの日本語"},{"content":"日语语法学习 听不懂暂停了，学完再来总结吧\n谓语 表示判断的助词：\n一般 礼貌 正式 正式+礼貌 郑重 肯定 だ です である であります でございます 否定 だはない ではありません / / / 表示主题的助词：～は/が\n—你是谁？—我是学生。私は学生だ。 —谁是学生？—我是学生。私が学生だ。 也：〜も\n私は学生です。彼も学生です。 指示代词 こ （离说话人）较近的事物 そ 离听话人近的事物/离得稍远的事物 あ 离（说话人、听话人都）很远的事物 ど 不定 〜れ、〜の、〜の〜 用来指代事物，一个+动词，一个+名词 〜ような 指代样态 このような本 こんな本\n都是“这样的书”的意思，第一个比较生硬、书面，第二个是缩略形式，常用于口语 〜こ 指代地点 ここは学校だ 这里是学校。 教室はどこ（何処）ですが。どこが教室でづが。 教室在什么地方？ 〜ちら（简写为 〜ち）指代地点，更加郑重，也可以间接指代人 こちら毛利探偵事務所でございます。　这里是毛利侦探事务所。 こちらは私の先生です。 这里是我的先生。 人称代词 第一人称 私（わたし）：女性常用，正式场合男女通用 私（わたくし）：更正式 僕（ぼく）：男常用，口语 俺（おれ）：上级对下级 俺様（おれさま）：男，粗鲁 あたし：女 うち：关西方言，女 第二人称 あなた（貴方）：避免对上级和前辈说，用于情侣间“亲爱的” 君（きみ）：男性对同辈 お前（おまえ）：男性对同辈，更随意 あんた：礼貌程度低 僕：对不认识的孩子 第三人称 人物（じんぶつ） 彼（かの）彼女（かのじ）こ/そ/あいつ：他/她/这家伙 モノ こ/そ/あ/どれ 复数表现 私たち：礼貌程度中 あなたがた：礼貌 彼ら：随意，不礼貌，表示第三人称一般这样说 私ども：最礼貌，只能自谦 敬称 佐藤様（さま）：常用，不分上下级，店家对客人 佐藤さん：广泛使用，较随意 佐藤君（くん）：对晚辈，一般对男性，工作中对女性也可以 佐藤ちゃん：亲昵 営業部長殿（どの） ：对职位，一般不用了，古老 佐藤氏（し）：姓氏 呼び捨て（よびすて） 不加任何敬称 形容词、形容动词 形容词 以い结尾，不用借助其他的助词 表示礼貌加です 直接加名词 例如：\n空は青い\n青い空\n形容词的不同形态： 形容词后面不再加任何句子成分（です除外），形容词用终止形 连接名词的形容词为连体形（体言） 形容动词 变换方式和动词一样\n例如：\n教室は静かだ。\n教室は静かです。\n形容动词的连体形 连体型：以な结尾\n例如：静かな教室\n形容动词的连用形 用言：分为三类，形容词、形容动词、动词\n连接助动词、小句的时候，用到连用形: 〜く/で\n例如：\n教室は大きく、静かだ。\n教室は静かで、大きい。\n〜ない この本　は　面白くない。 この本　は　面白くないです。 この本　は　おもしくありません。\n〜かった 过去式 昨日は寒かった。\n","permalink":"https://oooldgreen.github.io/posts/language/japanese-grammar/","summary":"\u003ch2 id=\"日语语法学习\"\u003e日语语法学习\u003c/h2\u003e\n\u003cp\u003e听不懂暂停了，学完再来总结吧\u003c/p\u003e","title":"日语语法汇总"},{"content":"记录每天的云不同的形状。\n青海的云每天都好美，觉得有必要开个帖子记录一下。恰好新买了相机，有事没事更新一下自己的照片也挺好的。\n7月16日下午 7月17日下午到晚上 7月17日下午到晚上 7月17日下午到晚上，那山上有个破旧的经幡 7月17日下午到晚上 7月17日晚上，像漫画一样的云 7月17日晚上，乱入一朵小花 7月17日晚上，黄河边，云是粉色的 7.18\n棉花云超好看，但是拍出来有点儿灰。\n这里的山像是被捏出来的一样 7.19\n有太阳，不太晴，有一层薄雾，无云。\n下午下雨啦，拍出的照片灰灰的，对焦也不太对，还要多学习。\n晚霞又是粉红色了 下雨之后的云 辣椒小白花儿 菜园子里的西瓜长老大了 小水洼的倒影，想把焦对在云上的 朋友在祁连，拍到了一条特别完整的彩虹🌈，下面是绿油油的小山丘。刷到七彩丹霞的彩虹，好看死了。\n7.20\n套了个links预设拍了天空，很喜欢这个质感。\n傍晚的时候睡了一觉，起来云很壮观，电闪雷鸣，但是只下了几滴雨。想碰见个大雨真难呀。晚上躁点实在很多，三脚架大概必不可少了吧。\n喜欢这个天空的质感，虽然这好像是绿叶预设 楼下晾着的被子 这根碍事的柱子终于被我拍了 云和山的缝隙只剩下一点点，透出亮光 像水墨画一样 7.21\n又拍了这根杆子，蓝色的天好纯净 蓝天套了预设所以不是特别蓝的蓝，今天的云薄薄的 7.22\n今天拍的长焦照片还是雾蒙蒙的，我知道是远处有雾了，不能怨我！稍微去了雾，所以莫名其妙多了个水印哈哈。这儿的天，这儿的云和山都太好看了，总也看不够。\n棉花云和下面绵延的山 一直特别想拍这个山，但总有电线杆挡住。镜头再拉近点，大自然像捏橡皮泥一样捏出这样的山，简直跟苹果地图的地势一模一样 7.23\n阴天，很多云，壮观 7.24\n加了日系滤镜，喜欢～拍了另一个但更喜欢这个预设 7.25\n终于带了相机遛弯，天空不负期待，红土山没拍到，但是这种不知道叫什么的云太漂亮了。一弯月牙远远的挂在天上。\n我发现早上总是很少的云，有雾，看不太清山 下午出现了乌云，分层了，有种压迫感 晚上出门遛弯看到的 再晚一些，到了镇子上，云就成了粉色了 随手拍了一张月亮，后悔没带长焦！不然一定绝了！ 7.26\n下雨啦，天气凉爽下来。\n早一些时候拍的 绕不开这根杆子干脆就拍进来 中间厚厚的云层，到了边缘就淡淡散开，像在水里化开了药剂 7.27\n看见像雾一样散开缠绕在山四周的云，溜回去换了长焦镜头拍。回来没多大会儿就下大了。\n神奇的云 时晴时阴的天气 7.28\n终于见到一小团一小团的云，在那么近的地方（看久了密恐呀 柱子的背景也有白白的云啦，发现不加滤镜更好呢 尼康的绿色拍出来也好漂亮啊 7.29\n天空和月亮。\n云拍多了，也想拍点别的，喜欢相机的质感 有点杂乱，午后阳光很强烈 夜晚，树影和渐变天空 这张的渐变更清楚些，我喜欢偏暗的色调，但看不清楚细节，下次一定记得把曝光调好～ 第一次自己拍到的月亮，细节纹理很漂亮 7.30\n有一群鸟飞过，啥也没调好但还好抓拍到一只，糊但喜欢 正儿八经拍到粉色的天空，发现这里每天傍晚都是粉色的 7.31\n大片的云，第一次显得没那么立体了 立体的云 又圆了一些的月亮 不知不觉7月也过完啦，来到这里已经半个月了，喜欢每天从窗子里看着外面的云发呆，也喜欢下完班和小朋友们一起去镇上玩。\n台风过境的日子里，这里还是一片祥和呢，天还是这么蓝，云还是这么丰富，夜晚的月亮还是那么亮，镇上的生活还是那么平静。戴着头巾的女人们和路边打牌的男人们一开始还会回头看着我们，后来也许习以为常。晚上他们通常坐在自己的店面前面，搬个小马扎，或者直接坐在台阶上。年老的人在乘凉，小朋友在打游戏。\n这里的经历比来之前想象到的要好得多。环境比我想的要好，遇到的困难都没有那么可怕，遇到的人反而都很温暖。这是一段暂时放下烦恼和焦虑的日子——看我的小书，学我杂七杂八的小东西，满足于当下，不用担心未来怎么样。除了偶尔想看电影和剧场表演之外，我好像也不需要那么多火锅，奶茶，电影，商场，酒吧。我好像回归了更原始的生活，健身，读书，散步，和朋友（同事）聊天，而不是沉溺在虚拟世界。发现或被迫或主动的放下一部分的物质，但生活仍然可以舒适。\n云的记录就先到这里啦，存在电脑的文件越来越大了，也该想想别的办法分享自己的图片了。生活会一直继续，学习拍照也会一直继续，以后的拍摄可能会另开帖子分享吧。\n最后，八月快乐呀💪\n","permalink":"https://oooldgreen.github.io/posts/daily/guanting-newlife/","summary":"\u003cp\u003e记录每天的云不同的形状。\u003c/p\u003e","title":"云的形状❤️"},{"content":"2023年的6月份，毕业之后，我终于完成了心心念念一年多的西北之旅，写下这篇西北旅游指南供自己回忆，希望也能帮助到其他想去玩的游人。\n一. 交通 1. 选择旅行时间 旺季是7月-8月，天气适宜，景色是最好的，草都绿了，可以看到大片的油菜花，缺点是贵，人多\n淡季5月-6月，天气不下雨不会太冷，草绿了但是油菜花开得少，景色不如旺季，优点是人较少，住宿机票相对便宜；1月-3月和10月份以后不推荐，虽然门票会便宜很多，但是太冷了湖都结冰了还会下雪；\n如果想看最好的景色且不差钱可以旺季去，如果预算有限，可以考虑避开旺季稍早一点去\n2. 来回交通 一般三种交通方式—飞机、高铁和动车\n✈️飞机：飞往西宁的飞机一般比较贵，可以看看飞往兰州的，再从兰州转车，缺点是比较累；当然也可以像我一样尽早买，多刷刷，捡漏买到早上七点的机票只花了三百七\n🚄高铁：一般坐的时间比较长，还可能要换乘，很累，不推荐\n🚊动车：有时间的推荐坐硬卧，睡一天就到了，价格也更能接受\n我的来回路费参考（23年6月中上旬，两人）：\n去程机票740RMB，返程硬卧火车票624+180RMB，共计1544RMB\n3. 当地交通 一般4种，报团、拼车、包车、自驾，除了自驾，不管是哪种都得记得查资质，选靠谱的\n💰各个价位都有，可以随喜选择，当然体验也会不同。旺季普遍会贵一些\n拼车：优点是相对便宜、路线比较自由，缺点是队友开盲盒；一般是2-8人，我拼了4-6人团，最后是4个人，队友新婚夫妇人还不错 包车：除了贵没缺点（贵是我的缺点），3-4个人及以上可以考虑直接包车，想去哪儿去哪儿，舒服 报团：最经济的选择，建议谨慎选择慎防踩坑，容易有购物 自驾：路其实还好，都是修好的路没有很难走，但是对开车人的精力是很大的挑战，又开又玩还可能高原缺氧，慎重选择 其实还可以选公共交通～西北景点较为分散，公共交通会比较麻烦，这个要根据自己的情况做取舍\n我的拼车路费参考（23年6月中上旬，两人）：\n1500RMB/人，属于正常价格，波动200左右属于正常，再便宜可能有隐形消费等坑\n附小马哥电话：17697293090 / 17809711397（微信直接搜即可）\n二. 住宿 路程是青海甘肃绕一圈，景点分散，所以住的地方也比较分散，基本上都是住1-2晚\n我的酒店选择标准： 1. 路线方便 2. 订新不订旧 3. 舒适不贵，所以基本是2-3星酒店\n预定app： 同程、携程、飞猪、去哪儿全网比价，哪个便宜订哪个\n以下是我8天7晚的住宿及体验，可以用做参考：\nDay 1—西宁蓝庭酒店（西宁市） 推荐指数：🌟🌟🌟\n城东区新千夜市这里一整栋楼都是酒店随便选，选这里是因为领队推荐逛新千夜市。\n优点： 价格挺便宜的，是23年新开的酒店，不缺插座，双人间比较宽敞。前台和老板态度都很好，早上10点就让我入住了，我定的房型还没退宿所以还升了房型。\n缺点： 窗户不太隔音，而且我们住的那个房间窗户有点问题锁不上，不过在23楼也就无所谓，晚上睡觉也没觉得很吵。早餐只有楼下的拉面，要么就向我一样稍微走5-10分钟有包子油条和回族特色早餐店\n这里提一嘴西宁的酒店大多数都没有空调（除非用钞能力），因为实在是不热没必要\n总结： 听地接姐姐说西宁酒店普遍都不错，价格也都不贵，这家就是中规中矩住的还挺舒适，其他家看看应该也不太会出错\nDay 2—茶卡艾特酒店（茶卡镇） 推荐指数：🌟🌟🌟🌟\n优点： 位置离茶卡盐湖很近，简直感觉刚出景区就到了，是在一个院子里很安静，没什么噪音；出门就有早餐晚餐和超市，很方便。可能是因为升级了房型，房间很大，窗外可以看见雪山！室内很温馨，两张舒适大床（具体不太清楚，可能一张1.5m一张1.8m），两个人睡很爽；洗漱台在外面，马桶和淋浴间是分开的，相当于三分离。\n我特别喜欢这个酒店的装潢！而且这个看见雪山真的快乐，大柴旦也看见了，早上看见心情可好了\n缺点： 插座没那么多，我只能占烧水壶的插座充充电宝。\n放张照片在这儿：\n总结： 茶卡的酒店我没怎么看，听地接姐姐说了就订了，是个惊喜，几乎没啥缺点，强推\nDay 3—大柴旦丽湖雅致酒店（大柴旦） 推荐指数：🌟\n优点： 大酒店，地理位置好，在翡翠步行街楼下有夜市，有免费司机房。房间挺大，楼下有热水，卫生间三分离，路上唯一遇到有一次性马桶坐垫的酒店。有加湿器（但是很吵晚上几乎没法用）。\n缺点： 前台态度太一般了，可能我去的时候住的人太多了，大厅就显得挺杂乱，一堆人拿着行李排队等电梯。最离谱的是遇到了晚上洗澡洗一半没有热水的事情，房间里甚至找不到前台电话，打电话还等了好一会儿才等来维修人员，一个陌生男的，话里话外还要责怪是我们自己不会弄。床很软，单纯的软但没有支撑，睡起来腰疼（这个见仁见智，也有人喜欢软床）。\n总结： 简直一星都不想给的酒店，避雷！可能因为小红书有挺多广告，感觉挺火的，人很多，这就造成服务很一般，不及时，第二天我们就退房了。听小马弟弟讲这地方旺季能上千，真心不值。\nDay 4—海西壹城雪原酒店（大柴旦） 推荐指数：🌟🌟🌟\n优点： 位置也在翡翠步行街，这条街其实很多酒店，吃东西很方便。前台说青普的小哥热情有趣。房间宽敞，热水充足，走廊智能灯挺好玩，床舒适，插头够用，有USB接口，还比丽湖雅致便宜。窗外看得到雪山🏔️！\n缺点： 好像没啥缺点，就是早上走的时候前台没人，只有张提示牌让我把房卡直接扔前台我有点懵哈哈\n总结： 不溢价的话住一两晚还是不错的\nDay 5 \u0026amp; Day 6—敦煌杏子酒店（敦煌） 推荐指数：🌟🌟🌟\n优点： 位置在沙洲夜市附近，网红店靖远尕六和思露杏皮茶都在附近。有加湿器且不吵，有洗衣机随便洗，洗完可以晾在小院子里，很方便！前台姐姐服务特别特别好，进出打招呼，会给你推荐去哪里玩怎么玩；电话叫都是立马上来，水只要要了就会给；我不会搞那个加湿器叫前台姐姐，她好温柔教我说敦煌水质不好加湿器要用矿泉水～\n缺点： 房间不是很大，床就是普普通通一米二（睡了一路大床大房间这个就显得有点小😂）。门不是很隔音，下午阿姨收拾很影响我睡觉。最大的问题是停电！其实推荐想给4🌟因为这个要扣1星，住了两天遇到两次，一次半夜一次下午，时间大概都要半小时，不知道是不是经常这样。\n总结： 综合来看感觉价格有一点点贵了，但住了两天我还是很喜欢这个酒店的，主要是因为前台姐姐！设施用起来也都蛮舒服，特别是加湿器和洗衣机强推！因为在敦煌玩会满身都是沙子，每天都在洗衣服刷鞋，可以晾在外面就干的很快。空调开的很凉快短时间倒不会很热，但停电还是造成了一定的不便，尤其是半夜停那次我刚好玩完满头沙子要洗澡233。\nDay 7—七彩丹霞彩虹湾酒店（七彩镇） 推荐指数：🌟🌟🌟🌟\n优点： 位置在七彩镇，但是不是在大路上，比较安静，附近照例很多吃的。有早餐，有人帮忙提行李，帮忙检查热水，还送了两杯杏皮茶（路上喝到最好喝的）\n缺点： 条件一般，早餐味道很一般，看到评论有说没热水的，有人提前帮我们检查了所以没遇到，我觉得还好。\n总结： 七彩镇离七彩丹霞很近，不在张掖市区，酒店感觉就是当地人开的，价格普遍比较便宜，设施比较一般，比如说床没那么软，卫生间比较简陋什么的，所以要求也不是很高，感觉已经算是镇上比较不错的酒店了。\n我的酒店价格参考（23年6月中上旬）：\n120RMB-240RMB，敦煌最贵，西宁最便宜，其他基本在150-180RMB，没算郑州住的那一晚，总花费1310RMB\n三. 行程安排 大西北的景点挺分散的，在路上的时间会很多，所谓的风景在路上嘛\n包车拼车旅行社给的路线很多都差不多，而且很多景点是看天气的，景点安排可以根据自己的喜好和当时的天气进行增删\n大部分景点都是要门票的，组成一般为景区门票➕景区内交通，有些交通是必买的有些不是，后面会讲，可以根据自身情况选择\n最后有门票汇总参考（旺季），淡季大部分景区会便宜一半\n放一张我觉得蛮实用的景点地图（最全的版本）：\n1. 行程参考 Day 1 西宁 景点： 塔尔寺、青海省博物馆、藏文化博物院、南山公园、青藏高原野生动物园等\n吃： 可以去 新千夜市，羊肉炕锅、羊肉串、手抓羊肉\u0026hellip;（关于羊肉的一切）、牛奶鸡蛋醪糟、酸奶、酿皮、甜醅、洋芋汤汤（其实就是土豆牛肉汤），多吃点好的，后面赶路中午一般吃不了啥\n简单介绍下景点，随喜选择——\n📍塔尔寺\n5A景区，藏传佛教格鲁派六大寺之一，先有塔后有寺，酥油花、壁画、堆绣是三大特色，门票70RMB\n这里可以说是西宁最著名的景点了，去的话要注意穿的保守点\n用时参考：3小时及以上\n交通：可以坐公交车901/908/913/916至塔尔湾村公交站下车，市区过去一个多小时；或者打车，方便快捷但贵\n我其实很想去但离市区有点远就没去～\n📍藏文化博物院\n藏医药文化博物馆是两个馆，藏文化和藏医药馆，有全世界最大的唐卡，第4层全都是，很震撼，门票56RMB\n用时参考：3-4小时\n我去的这个博物馆，蛮丰富的，就是五点钟藏医药馆就不让进了，所以只逛了一个馆\n📍南山公园\n可以在高处看到西宁夜景，会有居民玩耍跳舞，藏族广场舞？蛮有趣的\n用时参考：1-3小时\n📍下南关街\n一条当地回民街，我们最后一天带回家的吃的全在这里买的，零食水果蔬菜很全面（菜市场？\n这里还有西宁很著名的清真寺🕌️东关清真大寺，有兴趣的可以去逛逛，如果能看到做礼拜应该很震撼吧\nDay 2 西宁 -\u0026gt; 倒淌河 -\u0026gt; 青海湖 -\u0026gt; 茶卡盐湖 -\u0026gt; 茶卡镇 除了两个湖之外还可以看见雪山、成群的牛羊、大片的牧场，翻越2817m的高海拔。\n‼️ 第一次去两千多的海拔可能会气喘吁吁，尽量不要剧烈运动和洗澡。如果有不太好的反应最好路上备好氧气，求稳可以提前一周吃红景天（大部分人都不会有事啦，不用太紧张）\n路线 景点介绍 📍倒淌河\n一条倒淌的河，从东向西流，里面可以穿藏服和牦牛拍照，门票40RMB\n其实不推荐进去。看着太简陋了所以我们没有进去，只是在门口停留，可以看见远处的雪山\n📍青海湖\n青海湖周边为了保护环境22年以后都围起来了，不能再走牧民小道了，只有从二郎剑景区进入。门票89RMB/人，观光车不必买，很快就可以走到湖边。\n有水上运动可以玩，有经幡、转经筒，可以烧香拜佛。湖边有大群海鸥，可以喂海鸥。天气好就特别好看，蓝汪汪的，真的像蓝宝石～\n景区有很多吃的，可以在这里吃也可以出去在对面不远吃午饭。\n用时参考：2-3小时\n📍橡皮山\n途中要翻过橡皮山，2817m海拔纪念处！看惯了牧场景色之后突然出现很多山感觉也很不一样\n可以用很便宜的价格买到真的牛角刮痧板和梳子，如果要买一定要讲价，对半砍！\n📍茶卡盐湖\n到这里离茶卡镇就很近了，10分钟路程。\n柴达木盆地有名的天然结晶盐湖，分为天空之境和天空壹号两个景区，天空之境是新建的景区。我们去的是天空壹号，门票60RMB，小火车单程50RMB，几乎是必须坐的，走进去要4、5公里。\n游玩攻略：天气好可以看到漂亮的镜子一样的湖面，绝美。天气不好可以考虑别进了。如果住茶卡，看日出也是不错的选择。建议小火车坐到最后一站下来玩，再慢慢往回走，时间充裕可以走回来，嫌累就在那边买回程小火车。小火车差不多20分钟一趟，旺季最后一班去终点的小火车是19:00，最后一班返程是19:40，记得听广播把控好时间。\n⚠️ 不要买电瓶车，电瓶车进不去，只能小火车。\n⚠️ 不要光脚进盐湖，万一划出伤口你就知道了（又疼又难好）；租鞋套记得检查有没有破洞。\n用时参考：2-4小时\nDay 3 茶卡 -\u0026gt; 小柴旦湖 -\u0026gt; 察尔汗盐湖 -\u0026gt; 大柴旦 原本行程是从茶卡镇出发穿越柴达木盆地，开过蛮长一段路到达小柴旦湖短暂停留，掉转头去察尔汗盐湖，再走一段回头路去大柴旦翡翠湖，全程（算上回头路）六百多公里，住在大柴旦镇。但是在察尔汗盐湖有些晚了，没来得及去翡翠湖，挪到了第二天下午。\n路线 景点介绍 📍小柴旦湖\n路边的小盐湖，有缺口可以直接到湖边玩儿。简直是交通枢纽一般的存在，一路上至少遇到了三次，玩的时候直接到湖边，对面也有一些盐坑像镜子一样。后来再开车经过的时候，从另外的角度可以远远的看见黄色的草和蓝色的湖，风景画一样。\n一路上还会遇到很多这样的湖，东台西台吉乃尔湖之类的，不必都看完，会审美疲劳。\n用时参考：15-30分钟\n📍察尔汗盐湖\n全国最大、全世界第二大盐湖，其实是工业园区，不只是赚旅游钱，还会出产很多很多盐。所以可以看到很多大型器械。\n湖水色彩会和前面看到的都不一样，是苹果味儿汽水的颜色。白色的盐，绿色的湖水，肉眼看特别漂亮，无人机拍绝美，没有也无伤大雅，有了就是锦上添花。门票40RMB，大巴60RMB，坐大巴进去走过长长的盐桥才能看见湖。\n游玩攻略：坐大巴进去之后可以选择自己随便逛，沿着路走会有一些打卡点。也可以选择再买观光车坐到最里面去。毕竟是最大的湖，实在太太太大了，走进去挺累的，据说最里面有不一样的红色的湖，有秋千之类的打卡点，比外面要更漂亮一些。（这个就是自行选择了）景区内不进最里面的话也不必停留太久，大片的绿色虽然好看但还是有些单一，看多了也就那样了。最后大巴回程的时候会停在十里盐桥10分钟，没啥看的就一个碑，其实一路走的都是盐桥。\n我们回程的时候（晚上五六点）可能赶上进景区的人少出景区的人多，大巴进来的也少，排队等大巴排很久，游玩的话注意一下时间\n用时参考：1-3小时\nDay 4 大柴旦 -\u0026gt; 315国道 -\u0026gt; 水上雅丹 -\u0026gt; 翡翠湖 -\u0026gt; 大柴旦 路线从大柴旦始至大柴旦终，绕了一圈，两晚可以住在一个地方，轻装上阵。笔直的公路走着走着，不知不觉风景就变成了漫天的黄色，经过天路一样的315国道，游览世界上唯一的水上雅丹，本来应该再去南八仙魔鬼城观赏雅丹奇景（魔鬼城很大很大，那一整片其实都是）。但是我们转而去了翡翠湖，路上有一些雅丹地貌，也算看过了吧。\n路线 景点介绍 📍U型公路\n普普通通平直的315国道，要翻越过山坡，远远的看形成要开到天上的错觉，所以又叫天路。黄色荒山配柏油马路就很公路旅行风，有很多人会在这里停留拍照。\n⚠️ 建议别在马路中间拍照，这里有很多大货车经过，刹不住车的。命比拍美照重要多了好吧（纯属个人观点）。\n第一天见这种荒荒的景色，真的很好看，起伏的山丘，远处已经有一些雅丹地貌，再吹个不知道多少年沙丘的沙子会更细腻吧\n用时参考：15-30分钟\n📍乌素特水上雅丹地质公园\n世界上唯一的水上雅丹，在蓝绿色湖水之上冒出的一座座雅丹，神奇的大自然。门票60RMB，观光车60RMB。里面除了看水上雅丹地貌之外有一些游玩项目，游艇近距离观看之类的。\n游玩攻略：建议坐观光车，虽然最后一站离景区出口已经很近了，观光车是带你景区内绕一圈，第一站下直接到核心景区，再往回经过其他几站开到门口。后面几站都不如第一站好看，建议多停留一些时候，观景台看一看，湖边上看一看。后面几站有一些拍照点，第二站有一个小船，第三站是水上舰队（很多排列整齐的雅丹，无人机看很震撼），最后一站有一些经幡。观光车比较密集，后面几站下不下看你喜好。钞能力还可以坐越野车进最里面的景区看雅丹之眼，好像是一个车五百多，可以坐4个人。\n⚠️ 不能私自飞无人机，只有景区内报备过的无人机可以飞（花钱）\n⚠️ 蚊子巨多，做好心理建设，尽管不咬人，估计大家都呆不久😄\n路上远远的可以看到东西台吉乃尔湖，这里其实也有一些零星的水上雅丹，想省钱也许可以这里看看。小马弟弟说这里前几年还没水，很神奇。\n用时参考：1.5-2小时\n📍翡翠湖\n**强推！我的最爱！**也是盐湖，和之前的湖不同的是这里都是一个一个的小湖，五颜六色的蓝蓝绿绿，每个湖颜色都不太一样，远处还可以看到雪山，据说不同的时间点不同的天气进去看颜色都不一样。离大柴旦镇住的地方可能也就五六分钟，门票50RMB，小火车60RMB，不买小火车进去逛值哭了。不过也还是看天气的，天气好才更好看，不好也不至于像茶卡盐湖一样白茫茫一片😅\n游玩攻略：建议是不用买小火车，往返也没觉得有8公里？一路上都有风景。走路进去不远一边右边是一片白色的盐湖，人可以在上面走，180度掉转头远处就是雪山。然后去左边深蓝绿色的大湖（景区内不是第一大就是第二大的一个湖），这里有钢琴和路牌可以摆拍，钢琴排队；这里如果可以看到倒影，就可以拍到人的倒影和雪山的倒影。再往里走是著名的心形湖，水色透亮，盐桥上很多人拍照，无人机视角会很出片（上空才能看见心形呀）。再往前要拐弯儿，走右边是白色盐湖，有一艘船可以拍照。继续往前走右边是一个梦幻蓝色的湖（不知道咋形容了，特别好看），有一些摆摊卖吃的和蓝色冰淇淋的（这里蓝色冰淇淋比茶卡盐湖贵2块），走到这就可以折返了。返程继续沿右边走，这边的湖是黄绿色的，盐花儿都很特别，抄近道走过起伏的盐丘（我觉得盐丘也很好看）直接回景区门口。坐小火车的话就无脑一站一站坐着看就完事了，绕一圈路线安排的很好的，也不怎么排队。\n用时参考：3-4小时\n吃的 推荐一下离步行街也不是很远的伊布拉特色炕锅（终于吃上羊肉炕锅了😭），网上评分挺高，确实也好吃，服务态度不错，就是现做上菜比较慢（人多）\n还有一个伊品轩炕锅，就在步行街上，网上评价也不错，我没尝过\nDay 5 大柴旦 -\u0026gt; 无人区公路 -\u0026gt; 石油小镇 -\u0026gt; 沙漠露营 -\u0026gt; 敦煌 这一天走的才是真正的无人区，一路往海拔更低的地方开，天气越来越热。一整天几乎是用来赶路的，全程376公里。不过并不觉得累，晚些起床也可以。下午时分到达，休整之后傍晚去沙漠露营玩，看看沙漠中的夕阳。\n路线 景点介绍 📍阿克塞石油小镇\n废弃的石油小镇，曾经这里出产石油，石油没了之后人们也陆续迁走了，剩下这一片废墟。也是电影九层妖塔的拍摄地。门票好像是30RMB。如果不是废墟爱好者或者特别爱这部电影，不去也完全可以，感觉就是个拍照点。本来是不收费的，后来被带火了才建的景区。\n我们就是门口看看，没有进去，一眼望进去都是废墟，门口有一节火车\n用时参考：15分钟-1小时\n📍丝路遗产城 \u0026amp; 敦煌古城\n路途中还会经过这两个影视城，门票不贵30RMB。丝路遗产城有很大的大佛，敦煌古城可以租古装拍照，想拍照的可以去看。\n用时参考：30分钟-1小时\n📍沙漠露营\n其实这不算一个景点啦，是一个在沙漠里玩沙子狂欢的地方。在鸣沙山不远的地方一个村子里政府规划了很多地方用来开展沙漠露营，有不少选择，门票普遍两百多，有很多游玩项目，包含沙漠摩托、滑沙、香蕉车、乐队表演、自助餐、篝火晚会、简易露营装备等，另外收费的有骑骆驼、更高级的沙漠摩托还有进入沙漠深处看星星。可以搭帐篷住在里面，花钱可以住更好的。\n游玩攻略：建议穿洞洞鞋/拖鞋（沙漠别穿人字拖！）。沙漠摩托先玩一圈，很爽但也很快就结束了，可以让领队帮忙拍照。接着可以滑沙，滑沙板免费租借但要押金，押金条要保存好；玩的时候找坡度陡的地方否则容易滑不下来。香蕉船带你去更远的地方看夕阳，自己把握时间。晚餐基本就是自助餐和自助火锅两种选择，个人感觉自助餐比自助火锅的那种要好一些。沙漠里有水可以喝，自带一些更方便，不带也行。八点多有乐队live（我爱电吉他！），现场蛮嗨的。天黑后是篝火狂欢浪漫烟花一条龙。之后就随便玩了，沙丘上可以看到很多星星，可以让领队进来给拍星光沙漠照片。\n⚠️ 手机钥匙卡放好，能托管的就托管吧，掉沙漠里找不见。\n⚠️ 不建议住在这里，帐篷很简陋，大风更难受了（有钱住高级帐篷的当我没说\n⚠️ 当天一定要洗头，不洗头沙子在头发里过夜会很痒（你猜我怎么知道的😅\n那天风超级大，领队说明天不会要沙尘暴吧，隔了一天我们到七彩丹霞的时候就刷到敦煌沙尘暴了😅（可能这就是幸运儿吧。我们玩疯了，快十二点才回家，整个人都是沙人了搞到一两点才睡觉😅\n用时参考：4-5小时\nDay 6 敦煌 -\u0026gt; 莫高窟 -\u0026gt; 鸣沙山月牙泉 -\u0026gt; 敦煌 第六天就很纯粹在敦煌玩啦，最经典的莫高窟和鸣沙山月牙泉，这两个景点离市区都蛮近的。其实还有很多其他景点，比如敦煌博物馆、敦煌书院、榆林窟、西千佛洞、玉门关，还有又见敦煌表演。有时间的话可以多玩几天，也有那种为期一天的东西线包车可以选择。\n路线 景点介绍 📍莫高窟\n大量的壁画、石窟、文物，了解佛教和石窟壁画艺术的好地方，精美的不同朝代保存下来的藻井、飞天、佛像等等，真 看一眼少一眼。票价旺季238RMB，8个窟。淡季12个窟。每天开放预约6000人，如果没买到只好买应急票，100RMB，只能看4个窟而且不能只能在门口听。\n游玩攻略：首先会在数字展示中心看两场电影。第一场电影建议坐在后面靠走道的位置，内容讲莫高窟的由来，精彩程度一般；结束后从后门走，进入第二场电影影厅，建议坐在倒数3、4排的中间观影效果最好，身临其境。看完电影之后坐大巴去看窟，一组一组进，排队拿耳机，进去之前把耳机调试好，跟紧讲解员姐姐就好了。16、17窟和九层楼是必看的，其他窟根据当天情况随机讲解。听完讲解之后感兴趣的可以跟着应急票游客去蹭其他讲解（应急票的窟和正常全价票是不一样的）。下午14:00开放特窟展览，开放洞窟随机，200RMB/人/窟，需要排队买票，特窟听的时间会长一点，特别喜欢的可以考虑。看完洞窟之后还可以逛一逛展馆和文创，再往前走是邮局，可以买明信片直接寄出去。最后返程乘车点附近的数字展览中心还有一些复原窟和文物可以看，看完直接坐大巴出去。\n⚠️ 莫高窟一定要提前预约，飞天票可以在小程序抢\n⚠️ 到的时候能提前进但不能迟到，提前多少看卡的严不严，没买到早上票的也能碰碰运气\n⚠️ 听完讲解出了看洞窟的门就不能再进去了，只能在景区内其他地方逛，出口有标识看清楚\n用时参考：4-6小时\n📍鸣沙山月牙泉\n著名旅行景点，沙漠中看绿洲。有很多自费游玩项目，可以在这里骑骆驼、滑沙，玩滑翔机，甚至可以坐直升机俯瞰沙漠。\n游玩攻略： 穿拖鞋吧，不用租鞋套。别去太早否则沙子烫脚，晚上7点左右到就可以了。中门停车场很小附近可能堵车，自己走一下也不是很远。骆驼可以坐一下，但不是带你爬上山那种。观光车（好像是其他某个门进景区很远要坐观光车）会带你去月牙泉边上。也可以在这里租衣服拍照，也不是很贵，就是得早点去。然后就是爬沙山看月牙泉和日落，两条梯子🪜，左边那条也是滑沙的梯子，人比较多，景色也更好；右边那条坡度更缓一些，但风景不如左边。旺季不清场，想看星星估计得晚上11点之后了。\n我们又在沙山上坐到将近十一点，但是星星还是不是很多（周围太亮了），有大学生在放歌合唱，微风吹着，看着下面的月牙泉和城市灯光，很有氛围。满身都是沙子，没去夜市就回去睡觉了\n用时参考：3-4小时\n📍沙洲夜市\n虽然没去还是写一下😅\n敦煌最大的夜市，各种风味小吃和工艺品，天黑的晚所以热闹的也晚，十一二点去完全不用担心夜市关门。这里买小东西貌似很便宜，可以砍价很多。\n用时参考：1-3小时\n📍又见敦煌\n一场蛮著名的剧，可以选择晚上去看，或者看完莫高窟之后去，看完再去鸣沙山正好\n我没去因为回去睡觉了～敦煌实在太热了！\n吃的 靖远尕六排队贼厉害，下午一点多去还要排队一个多小时。想吃的可以试试\n思露杏皮茶好喝！推荐玫瑰味儿的那个醪糟还有青稞甜醅\n杏皮茶随便买的就挺好喝，随便点的拉条也好吃\nDay 7 敦煌 -\u0026gt; 嘉峪关 -\u0026gt; 七彩丹霞 -\u0026gt; 张掖七彩镇 又要赶路啦！敦煌到张掖是全程走的最远的一天，583公里，所以被迫要早起～\n途径瓜洲收费站，不买东西吃瓜也免费（这里瓜不值钱），如果停留休息的话可以多吃点，好吃的。\n看别人的攻略张掖也挺好玩的，有时间可以在这里多玩几天。\n路线 景点介绍 📍嘉峪关\n甘肃著名历史遗迹。明长城西端的第一重关，分为内城、外城和城壕，进入内城登上城楼可以看到祁连山麓。门票110RMB。\n中午在这里吃饭，然后在门口晃了一下吃了个奶糕😄（本人对关城不感兴趣），门口拍照留念之后进去走一段路才是检票口，小路一边有芦苇荡，另一边还有一些没修好的地方（23年6月）。从检票口可以看到天下雄关几个字\n用时参考：1-3小时\n📍七彩丹霞\n丹霞地貌，主要是红色砾石、砂岩、泥岩，行成条纹状的彩色纹理（好多广告拍的可好看，调色了别信，门票包含观光车93RMB\n游玩攻略：下午晚些去，不热还可以看夕阳和夕阳下的丹霞（据说刚下过雨更漂亮。大巴车停四站，第一站最普通，第四站最好看。第四站还可以坐热气球。多花钱可以更深入，人少。理论上从哪个门进就要从哪个门出，大巴上车点会标注的很明确可以注意一下。\n这个景点非常看天气和运气，刷到过好多人进去看到的是一片灰秃秃。但是我们去的时候夕阳把丹霞照的很鲜艳明亮，也算是没有遗憾了。我们直接略过了第一站，只看了第二、三、四站。\n⚠️ 这里也不能飞无人机。\n⚠️ 住附近的话别住太偏，七彩镇吃的多，其他地方就比较村，不那么方便\n用时参考：2-3小时\nDay 8 张掖 -\u0026gt; 扁都口 -\u0026gt; 祁连山大草原 -\u0026gt; 岗什卡雪峰 -\u0026gt; 门源油菜花（7月花海）-\u0026gt; 达阪山观景台 -\u0026gt; 西宁 终于可以看到绿色的一天，一望无际的大草原，成群的牦牛和羊羊。翻过祁连山脉，看看雪山和油菜花，回到西宁结束行程。一整天没门票费啦，都是自然风光。\n路线 理论上是这样的，张掖真大啊，走半天还没走出去。我们没去看油菜花和雪山，一路上都在翻山，雾蒙蒙的，所以到西宁特别早😅\n景点介绍 我介绍不了😭，我去的这天下雨了没看见雪山，油菜花也没长多少，后面都没看到😭，就简单说下草原\n📍祁连大草原\n草原当然是非常大啦，路边有地方就可以随便停着看，很多牛牛和羊羊，随便拍。然后就是翻祁连山，山里全程很好看，山上动不动全是羊，五颜六色的羊🐑，走很多弯道和隧道，海拔又高达两千八百多米。\n游玩攻略：除了看草原牛羊拍拍照其实还有那种当地居民划分的草原，进去有一些项目，骑马、穿藏服拍照之类的，骑马拍照溜一圈什么的几十块钱也不贵，感兴趣的可以去玩。这里可以看到很多可爱的兔鼠（当地人这么叫）！它们在草原上打很多很多洞洞。抓兔鼠玩别跑太快，气喘。再往前还有一处超级大的经幡，卖糯米做的隆达纸（祈福用的），几块钱一大把，可以买来玩。\n⚠️ 海拔重新变高要把厚一点的衣服拿出来，千万别穿短裤了。\n⚠️ 没景区就别太期待厕所啦\n📍岗什卡雪峰\n雪山哎！谁不想看！那个观景台应该就是看雪山最好的位置\n告领队诈骗（一路上都在说最后一天可以看到雪山！虽然前面也看到了，六月份山上还在下雪，但其实被雪覆盖的部分并没有很多。所以我怀疑这个雪山最好看！没看到很伤心😭\n📍门源油菜花海\n不要钱在外面看就可以，七八月份开了很好看，六月份去就只有稀稀拉拉，其他时间就不用去了。\n我们经过张掖的农作物，油菜花开得还不茂盛，绿色和黄色夹杂着；有一种紫色的小花很好看，不知道叫啥\n2. 门票价格汇总 ⚠️ 有学生证就买学生票，研究生证几乎没用（拴q\n⚠️ 除莫高窟旺季需要提前预约，其他的基本上当天买即可\n地点 景点名称 价格（RMB） 备注 西宁 塔尔寺 70 西宁 藏医药文化博物院 56 语音讲解20RMB，建议租一个 海南州共和县 青海湖 89 观光车没必要 海西州茶卡镇 茶卡盐湖 60 小火车单程50RMB，必买（自行选择单程or来回） 海西州格尔木市 察尔汗盐湖 40 大巴60RMB，套票会包含在一起。观光车另外付费，随喜选择 海西州 乌素特水上雅丹地质公园 60 观光车60RMB，建议购买 海西州大柴旦镇 翡翠湖 50 小火车60RMB，景区路程不远，想轻松可以买 酒泉市敦煌市 莫高窟 238 旺季全价票8个窟，淡季12个窟，应急票4个窟100RMB 酒泉市敦煌市 鸣沙山月牙泉 110 买一次能进去三天，可以合理安排一下时间 张掖市 七彩丹霞 93 包含观光车 我的门票价格参考（23年6月中上旬，两位成人票）：\n所有门票➕交通，总花费约2000RMB，沙漠露营两人456RMB\n四. 出发前准备 证件类： 身份证、学生证\n日常用品类：\n防晒霜（❗️特别要注意防晒） 遮阳伞（天气多变，也能当雨伞） 遮阳帽 墨镜（阳光刺眼） 冲锋衣（必带，下雨冷到内胆也要穿） 补水保湿用品、面膜（天气干燥） 保温杯（高海拔最好喝热水，一般酒店和吃饭的地方都有热水接） 洗漱用品、吹风机、拖鞋酒店一般都有，按自己习惯带即可 药品类：\n晕车药（晕车人士必备） 普通感冒药，治嗓子的药（高反吹大风容易有点不舒服） 肠胃药（水土不服可能便秘或拉肚子） 高反药（看情况准备，红景天要提前一周吃，葡萄糖可以缓解） 其他： 建议带无人机\n关于高反，海拔比较高的就是前两天，到敦煌就只有一千多了。我们车上的人都没有高反，但是有人会有气短，容易疲劳等现象。我下雨吹风之后有点流鼻涕吃了两次药就好了。\n关于天气干燥，我们车上有人流了鼻血，所以一定记得保湿和多喝水。\n","permalink":"https://oooldgreen.github.io/posts/travel/northwest-guide/","summary":"\u003cp\u003e2023年的6月份，毕业之后，我终于完成了心心念念一年多的西北之旅，写下这篇西北旅游指南供自己回忆，希望也能帮助到其他想去玩的游人。\u003c/p\u003e","title":"西北大环线旅游指南"},{"content":"算算6月18日从西北回来已经有两周了，念念不忘，整理了许多照片，发了小红书，当然也要记录在我的网页里，可以写大段的文字才更爽啊～\n这段经历前接我痛苦的研究生生活，后接7月份工作的未知，显得愈发美好了，必然成为我以后常常怀念的一个星期。\n出行方式是价格最合适的拼车，领队是很早就在小红书找好的，6.11-6.18七天的拼车。因为小红书上实在太多小马哥广告，看太多实在累了，随便定了一个价格差不多行程差不多的，佛系下了定金。很晚了还没有拼团成功，一度让我很紧张。不过最后是四人成行，去之前还很焦虑了一些时候，担心天气不好、同行的人相处不好、高反等等很多问题，加上妈妈身体那段时间也不太好，非常担心她坐车不适应。后来想想都是我不可控的东西，也就躺平了。\n提前一个多月订了10号郑州到西宁的飞机，三百多拿下的很快乐😄。但是出了点小状况，地接姐姐说她那边不能安排接机了只能给我钱让我自己打车去酒店，对我来说不是啥大事，就直接预约了接机。\nDay 1 落地西宁 6月9日下午从家里坐车去郑州，再坐城际列车转到郑州机场之后直奔酒店。第一次坐城际列车，地图上查到要一个小时的路线十五分钟就到了，很惊喜！\n第一晚住在了郑州机场附近，住宿环境并不好，就不多提。\n第二天一早四点多酒店就派车载我们去机场。时隔五年第一次坐飞机，又是从郑州，恍若隔世。所幸流程还没忘，取机票，托运，过安检，登记，一气呵成没出岔子。\n接机的姐姐比我预约的时间提前半小时就已经在等我了，好像提前知道我的飞机早点了一样😊。见面也好惊喜啊！看起来很干练利落，车是亮眼的蓝色，一眼爱了，态度也好好，我一百个好评好吗。环城高速上看到一大排军用车，还看到一辆卡车后面全是兵，接机姐姐说应该是演习。很神奇的体验，第一次见。\n酒店订在了城东回民区，早上十点就入住了，我定的房型还没退房所以升级了房型（感谢）。这一整栋楼其实都是宾馆，我定的酒店只占了一层，老板是个看起来蛮老实（？的回族男人，前台几个看起来也像是回族的漂亮小姑娘。然后出去逛➕吃饭，出门就被门口拉面香味儿迷住了，也没去吃著名的炕锅啥的，直接停下了😂住在回民区其实还蛮稀奇的，自己不带头巾反而格格不入的感觉，整个面馆也只能找到我跟我妈两个人。面很大碗，之后环线的饭都是很大碗（拴q）\n吃完饭睡了一觉，慢悠悠去逛了藏文化博物馆，直奔唐卡，看了很久很久，主要因为内容多。很全面很全面，震惊🤯，看到了一些关于藏医药的东西，再配合上一路看到的藏医医院之类的，一直只知道中药却不知道藏药，也蛮有趣的。但是唐卡里印象最深刻的是天葬，因为刚看完尾鱼的怨气撞铃😂，尾鱼描写的和那个画对上了—一只秃鹫正把肠子从一个人身体里拽出来，给我留下了深深的阴影👋。不过呢天葬应该还会把人切成块的。自认为不是老古董，但是切成块还是很难接受，总让人想到，杀人分尸😅。\n晚上回去逛了新千夜市，酸奶我觉得一般，但我很爱牛奶鸡蛋醪糟！烤牦牛肉串不如羊肉串好吃，之后吃的羊肉串都没有腥膻味，很香。还被小摊贩说了看你们穿冲锋衣就不是本地人哈哈哈哈哈。确实西宁倒也还不至于说非常冷，就很凉爽的天气，羡慕麻了😭。\n妈妈提了一嘴觉得有点喘不过来气，力劝她买氧气，未果。我就想早点回去睡觉，结果发现那个天迟迟不黑？才想起来这里是有时差的，九点多太阳才会落山。感叹中国真大啊。夜幕慢慢降临，带着新鲜感从窗户拍了一张西宁半夜不夜的景，华灯初上，很漂亮。白昼很长，我喜欢～\nDay 2 青海湖到天空之境 6.11\n第一天正式开始。\n因为吃过楼底下的拉面了，早饭问了酒店老板，老板另指了地方，所以在附近不远吃的。饼（狗浇尿）和花卷还挺好的，咸奶茶怪怪的喝不惯；还点了洋芋汤汤，洋芋就是土豆🥔，里面还有牛肉，蛮神奇的。最后又跑去对面买了胡萝卜牛肉包子，一路上有很多胡萝卜🥕包子。\n小马弟弟八点到早饭的地方来接，先接我们，再去接另外两个人，i人很忐忑，不知道会遇到什么样的队友。队友是一男一女新婚夫妻，同行的女生我一眼就看到她带了相机，她的相机好可爱哦！镜头盖都是小熊猫🐼。还好她还蛮健谈，不至于一路上死一般的沉寂和尴尬。\n一路上就是我们问小马弟弟答，这个时候的小马弟弟还显得很乖。对一切都很好奇的四个人，问了寺庙问牛羊，眼前的景色一切都是新的。中途停了一次车，下来看雪山，第一次真的看见山顶上覆盖着白雪。\n我问小马，你是什么族呀？他答：回族。回族人长得还是不一样的。他说很多回族人都姓马，后来才知道他是穆斯林，姓马并不是他本来的名字。尽管我认识有回族人，土家族人等等，从没觉得大家有什么分别。这也是我第一次如此近距离的感受到民族和宗教作用在人身上所造成的不同。书上看来的，播客里听来的那些仿佛近在眼前了。\n📍倒淌河\n到倒淌河的时候并没进景区，领队也不推荐，我也无所谓，而且门口看着属实有点寒碜了😅。风超级大，瑟瑟发抖的掏出冲锋衣内胆，跟远处的雪山🏔️拍了两张合影。不过倒淌河好像可以骑牦牛呢！太冷了，风吹的我瑟瑟发抖，高原已经不能跑来跑去了。\n📍青海湖\n再上路遇到很多羊群牛群，有我最喜欢的牦牛🦬，牦牛真的好好看啊，尤其是黑色牦牛（没文化只会说好看）。走着走着远远的天边出现一线蓝，我知道那里就是青海湖了。看到湖大家都很兴奋🥰\n到青海湖景区的时候天气就很好很好，大片大片漂亮的云，湖水远看是大片的蓝色，近看还蛮清澈。这里我们进了景区但没有买观光车，到湖边就很近，很快就走到了，不累。青海的天真的美。我从没见过那么大团的连成片的云，像动画片一样。景区里有转经筒，有经幡，尾鱼又在我脑子里作祟了～然后就是拍拍照玩玩水，咸水湖玩完手都是黏糊糊的。第一次见哎！拍了那两颗著名的树，给可爱的海鸥录了很久的视频，浮在水面上两只脚在下面扑腾感觉很可爱，水太清澈了看的可清楚了！这里妈妈说走得快了会喘，所以后面一路都在问小马弟弟这里多高那里多高哈哈哈。他只嘱咐我们不要乱跑不要洗澡，一般人都没事的。\n📍橡皮山\n走着走着突然景色和之前的不太一样，出现了很多的山丘，但还不是秃山，上面覆盖了植物。然后开始上山，茫然的我，走到上面才知道这里3817m是路程里最高的海拔了西北带给我第一天的新奇，看什么都很有趣，远处的山和云，脚下的青草，空气中弥漫的牛粪味儿，山上卖的牦牛皮草，甚至收费的厕所。这里的人遮挡的真严实呀，只露出两只眼睛，可以看到眼睛周围黑色的皮肤和岁月留下的刻痕。\n📍茶卡盐湖\n路上下雨了☔️，天气预报一整天都在预报有雨，也不是很意外。从车窗里往外看，一边的云快要贴到地面上，遮住了起伏的山丘；另一边是明亮的色彩，蓝色的天和绵延的白云，白云中透出光来，神奇的天象。\n到茶卡盐湖其实已经不早了，青海湖的时候因为大家沟通不及时耽误了点时间，我们几乎赶着最后一波进了景区（所以后面玩到九点多的人我是真的很佩服啊！）。下车的时候还在下雨，小马弟弟让我们拿了他的伞🌂，这个时候觉得他人还怪好的嘞。他说不会下很久。我讨厌湿掉的网眼鞋。\n于是大家在游客中心逗留了一会儿，几乎不下了我们就出去了。风真的很大，伞根本打不住的程度，幸好有冲锋衣防水防风。路上碰见有人高反在吐，挺吓人的其实。接着就是整个旅行中我最不爽的时候了，因为没做攻略第一站就下车看了盐雕，风很大但心情还是蛮好的。然后慢慢往前走了（这个时候完全忘记了小火车站台的事情）。在下雨湖面并没有很好看，是浑浊的，可以看到下面的盐，但是云还是很好看，简直看不够。一直走到租鞋套的地方才反应过来小火车只能在站台坐，问了工作人员下一站还有两公里\u0026hellip;这个时候我已经走累了，就只能往回走，走到一半走不动了。警卫大叔说小火车会停在附近，那个地方没有站牌，所以我跟我妈在寒风中坐了一会儿，心有不安，还是决定往回走到下车的地方。小火车20分钟才一趟，那个时候时间很晚了我们都开始着急，但还是没赶上眼前这一辆 （实在不敢用跑的，而且可能因为海拔比较高，感觉真的很累了）。就只能继续问工作人员下一趟什么时候，没想到工作人员说，七点了已经是最后一辆了，广播很久了，然后我就懵了，一直都在路上就真的没听到，跑来跑去很累还啥也没看\u0026hellip;但是大叔人还挺好的，帮我们安排了可以直接从返回站坐回景区门口，不用额外买返程票。这个时候风啊雨啊差不多都停了，湖面变得平静起来，我们只能慢悠悠的又走回去返程的站台，离谱的是就在租鞋套的对面，又走了一遍😅。\n这个时候湖面像镜子一样了，云的倒影山的倒影看得好清楚虽然一开始蛮难受的，最后接受了现实坐在湖边看这上下两个世界心情就平静下来了。也会想终点站会不会更漂亮呢？这么幸运可以看到倒影呢。转念一想留下点遗憾也算正常。回程很顺利，人已经少了很多，天还没有黑，我们又慢慢悠悠的经过那片湿地，出景区的时候正好撞见美丽的夕阳。我对着夕阳拍了照，小马弟弟在我后面说啊我也拍了这个。\n没想到酒店是一座独栋，还升了房间，两张床都很大，外面可以看见雪山。因为很累又很冷，出门只随便吃了一点就回去睡觉了。好喜欢这个酒店呀。\nDay 3 盐湖之旅 6.12\n定了九点出发，但是很早就醒了，出门吃饭逛超市，出门觉得特别特别冷，吃了饭才好一些。但是也没买啥，路上不爱吃东西。早饭米粥包子和油条，这里米粥叫稀饭，一碗五块，挺贵的，大哥说米很稀罕，我也觉得，能喝米粥就已经很好啦。\n📍小柴旦湖\n在路上挺久，途径小柴旦湖，下来玩。好看！就是湖边上行人也有好几波了，小马弟弟还有其他几个司机都是认识的，总是停在一起讲话，感觉也挺快乐的。\n远山，白云，笔直的公路，湖对面还有小盐湖坑，倒映出蓝天和一簇一簇的白云。小水坑彻底变成镜子了。大家都在拍照，我在路边吹吹风，很舒服，还得是好天气呀～\n📍察尔汗盐湖\n下午才到，到的时候阳光还很刺眼。这次吸取教训看了攻略。听说湖水呢中午是不好看的，光比太大啦。\n察尔汗盐湖是全国最大的盐湖了，也是好大一片工业区，进去就是坐大巴走盐桥。大巴进去一路上就很多湖，还想怎么没有别人写的一拐弯就很惊艳呀。开进去才领略到，原来说的根本不是外面那些湖啊～下车走近满眼都是那一大片湖，青苹果味汽水的颜色，看起来很好喝的样子，但是广播一直在说卤水有毒哈哈。\n慢慢往里逛，白色的盐像雪一样，苹果绿的湖，朱红色的小亭子，拍了一麻袋照片。路上碰见队友，最后是一起走回去准备返程的，感觉时间把握的贼好，还没开始骄傲发现居然还要排很久的队。可能那个时候刚好进景区的人很少出去的人很多吧。万丈盐桥停了十分钟，但是排队累了只看了一眼，毕竟走了一路都是盐桥呀，一个碑又有什么好看的，还不如脚下的路稀罕。因为排队出去的时候有点晚了，改成第二天去翡翠湖了，我心里没底，一直问来得及吗来得及吗。小马弟弟说来得及，那就相信他吧。\n住在大柴旦，感觉是比茶卡镇要大一点的镇子。终于吃上羊肉炕锅！这里羊肉说实话都挺好吃的，好像没吃到不好吃的～风吹的挺大，在广场上又看见雪山，虽然不是很多～广场上看到那些小朋友在广场上玩耍，和家里的广场别无二致，恍惚间觉得这个地方好熟悉呀。\n回酒店已经很晚了，但是在茶卡不敢洗澡，在这里还是要洗，在这里洗澡是发生了些不愉快的，略去不提，第二天就收拾收拾搬了出去。后来才知道这家酒店是有司机房的呀，还挺会做生意的嘛。\nDay 4 公路旅行 这天的路线是从大柴旦出发玩一圈再回到大柴旦。\n📍U型公路\n沿着公路一直往前开，笔直的一条，黄土和公路很配，想到末路狂花，公路旅行，等等等等。来到一个斜坡，原来这就是天路哈哈，因为坡度比较陡，看起来确实要开到天上去。一条被互联网带火的一条公路。第一个斜坡人太多了，我们还去了第二个斜坡才停下，人也还是挺多？挺多人在这里拍照，在路中间，感觉好危险。大车下坡刹不住车会按一路的喇叭。怎么说呢？可能因为新奇吧，我喜欢这儿。比城市里好。\n路边已经有了一些小的雅丹土堆，也很神奇，站在土坡坡上拍了无人机，还挺有意思的。我穿黑色，简直是我的本命颜色啊好爱。是用小马弟弟朋友的无人机，好像建议他买个无人机呀，提升用户体验好吗。小风吹着，阳光明媚，又是一天好天气呀～在这里上厕所，结果遇到了旱厕😱，好久没遇到了，还是很难接受啊！跑回车上评论了一句：可怕；小马弟弟：就知道你会说可怕😅\n📍水上雅丹\n全球唯一在水上的雅丹。第一站下来就是最核心的景区，湖水很蓝，配上凸出水面形态不一的雅丹，独特的风味。但是拍人像就还蛮看角度的。在这里捡到了房卡，就近交给了景区的人。后面几站还有小船，海上舰队，我最爱的经幡。蚊子实在太多了，走上小船就像立马落荒而逃了呀。想坐下等观光车，低头一看板凳上全是蚊子的尸体，有一对上海母女在等车的地方吵架，母亲撑着把伞坐在那，哪里也不去哈哈。小马弟弟说这个蚊子不咬人，那也很可怕啊！！！\n📍翡翠湖\n从水上雅丹出来，路上睡的很好，快到翡翠湖我就醒了，已经可以看见雪山了。天又阴阴的，西北天气真是多变。\n是小马弟弟说比翡翠湖还要绝的地方。这个地方竟然真的可以不买小火车的，景区自己就能慢慢逛完，来回也没觉得有8公里。进了景区一回头就可以看见雪山，雪山下面还是黄色的草，再近一些就是白色的盐湖，湖上独特的纹理，自然就是不需要修饰就很美。\n这里不是茶卡盐湖和察尔汗盐湖那样大片的湖，是一个一个分散的湖，每个湖的颜色都不太一样——五颜六色的蓝蓝绿绿，青绿、深绿、翠绿、湖蓝、黄绿…每一个都跟上一个不一样的漂亮，就很有惊喜。一开始天是阴阴的，我们还觉得没有那么惊艳。在心形湖太阳差不多就出来了，湖水的颜色顿时变得太美了，像一块玉石，又如此通透。中间盐桥太多人拍照了，无人机从上面拍确实是会很好看的。我和妈妈在湖边坐着，蓝绿色水波在眼前晃呀晃，世界上怎么有这么美的色彩呀！本来觉得这个已经很好看了，再往里面走又被里面蓝蓝的湖惊艳！走了一路看了许多湖，这个蓝色仍然是唯一的，太独特了。沿着这个湖走就到了一片小摊贩，有卖蓝色冰淇淋的，不得不说真会挣钱啊，就是和湖水蓝天很配啊这个海盐冰淇淋。如果不是贫穷阻止我，我也很想买啊！\n随便坐在景区修的木地板上，感觉对面小房子蛮好看的，拍下来才发现是卫生间哈哈。坐在那休息了很久，对着湖水吹着微风整个人都在出神，没有杂念，嘈杂人声好像离我都远了。\n返程走另一边，是黄绿色的湖水，也很特别，都是和别处不一样的，盐花很多。太阳很好，我们慢悠悠走回门口，可以看到雪山清晰的倒影。没想到太慢了要让另外两个人等着我们，怪不好意思的。就那么一会儿觉得景区出口怎么这么远呀！进来的时候也没觉得呀！\n出景区只剩夕阳了，草原上有一些水坑，几匹马在低头吃草。\n回到酒店，位置也很好找，前台小哥说青普说的很有趣（虽然也没听懂）。真的对语言很有兴趣，想学两句青海话，唯一认识的小马弟弟不肯教。小气鬼！\nDay 5 穿越无人区 这一天开到敦煌去。笔直的公路，大片的无人区，起伏的山丘，有一些已经细腻到像是沙漠。\n已经忘记是哪一天见到了野骆驼🐫，瘦瘦的，在大太阳底下晒着，我都替它热。另一边有潺潺的流水，很细的一条，骆驼呀就靠这个水喝一次顶很久嘛？\n同行的小伙伴想去看看敦煌古城，太热了太晒了我和妈妈不想动，在车上等，和领队有一搭没一搭的聊天。车上挂着的叫做星月的串子，一根真的一根假的，去张掖很困的时候我看见他拿在手里数珠子（笑死）。\n天虽然热，但是风也好大，暖烘烘的风把旗子吹得一直吱呀作响。\n晚上去沙漠露营玩儿，对i人来说，狂欢与我无关，所以并没有很期待玩耍，比较期待看到沙漠🏜️。第一次见到沙漠呀～也没觉得仪式感什么的，大沙场嘛！唯一就是因为没带脑子，穿了网眼鞋进去，回去还刷鞋。一开始觉得票价好贵哦，不过贵就贵吧，反正出来玩嘛！\n先坐了沙漠摩托，刺激，然而一圈很快就结束了。接着借板子去滑沙。租滑沙板的老板也怪有意思，一对小情侣寄存了自己的手机，问能不能把手表压在那儿算押金，老板不要，说不收押金了，全凭信任。然而滑沙的小山坡是真的上不去😮‍💨，向上迈一步陷进去半步，累死我了。实在爬不动，滑了一回就去看夕阳了。其实就是开到沙漠深处一点的地方看看。沙漠上很多摩托开过的痕迹。阳光还是有点强，一打眼沙漠像金子一样在闪光。沙漠上稀疏的还长了一些顽强的草。\n吃顿饭的功夫外面天都暗了，拿了罐青稞啤酒出来，喝着啤酒看了一会儿逐渐亮起来的灯，蓝调时间～我眯着眼睛享受。等了一小会儿就是演出开始，找把椅子坐下，在不远处看舞台表演。 一支蛮有活力的乐队，一撮人聚在台前，氛围很嗨，还有人买荧光棒挥舞。远远的看着热闹就很开心。坐累了我就只是躺在沙漠里听着不远处的热闹，视线里秋千和跷跷板全都倾斜。突然听到要燃起篝火，站起身来就看到火焰🔥在暮色里窜高，人群手拉手围着篝火跳舞。后来还放了烟花🎆，真的很爱烟花，究极浪漫。再后来我就躺在那看星星，周围光太亮了看得并不多，也拍不出，但是很惬意。现在我已经学会拍星星啦，甚至还想买相机📷啦，未来也有机会拍星星的吧。毕竟马上还是要去西边学习😊。\n小马弟弟吃了饭之后也来玩儿，招呼我上沙丘，我全身心拒绝了。但是又真的很想看星星，自己默默爬上去，发现大家都在上面呀！就觉得真好呀！晚上沙丘上的风很大很大，吹的我满头满脸的沙子。能看到很多星星✨ 和对面灯火通明的露营地。北斗七星好显眼呀，还有很多很多其他的星星，不过我都不认识了。领队哥哥在给那一队年轻小姑娘们拍沙漠星空照。小马弟弟是坏人，风都这么大了，还要撩拨着沙子，那些沙子全都乘着风飘向拍照的姑娘们。后面被发现了就是打打闹闹，简直像10岁小孩会做出的动作。我也说了句傻话，我说我一直这么坐下去会不会坐成沙雕呀。同车的姐姐爆笑。\n我最喜欢坐在沙丘上的感觉，虽然被狂风吹的很凌乱。会愿意一直坐在上面的程度，很幸福。\n沙漠的风有种狂野的自由。\nDay 6 敦煌！敦煌！ 6.15\n今日重点莫高窟，鸣沙山月牙泉。我是提前一个月就预约了莫高窟9点钟的票。6月可能还没有那么旺，同车的小伙伴很晚才预约也约到了九点半，所以八点多大家顺利的一起进去了。据说是可以早但不可以晚，所以几乎是一路上起的最早的一天了（前一天还睡的很晚），不过为了莫高窟也是值得吧。\n📍莫高窟\n莫高窟是我收藏最多攻略的地方，所以流程很熟悉跟想的一模一样。先看两场电影。第一场讲莫高窟的历史，比较一般已经不太记得了（很困好吧）。结束之后直接从后面的门出去进入第二场电影的球幕影厅，顺利坐在了倒数第三排的正中间。这个球幕电影真的神奇，第一次看这样形式的电影，身临其境，屏幕动的时候感觉是自己的椅子在动，有种晕晕乎乎的感觉。影片介绍了好几个窟，很漂亮，但是我真的太困了，很努力不闭上眼睛😆。结束的时候妈妈说都听见旁边人打呼噜了哈哈。\n接着坐大巴去看窟，闭目养神一会儿就到了。下车九点多太阳非常非常热烈 （不愧是敦煌），排队的人也还蛮多，不过没排很久工作人员喊前面缺两个人我和妈妈直接就去了。 然后就是神奇的一个多小时～讲解员很专业，声音很温柔，每个窟也讲了蛮久的，没有我刷到的5分钟一个窟。除了固定的1617和九层楼，还参观了323、328、329、292和61号窟，看到了不同朝代所采用的不同的顶部以及佛像塑造的变化。印象最深刻的是飞天，飞天真的还蛮好看。和墙壁上被拓走的一大片空白，真的很遗憾。九层楼大佛也很震撼，从下面看到感觉自己很渺小。但是太快了，只能走一圈，体验其实并不是非常好。\n出来之后讲解姐姐有说我们可以去蹭应急票的窟在外面听一听，妈妈觉得咱也看不懂，就直接出去了。我在这儿吃了两个冰淇淋！一个葡萄味儿的三兔共耳，一个草莓味儿的九层楼！可开心了！ 穿过葡萄架子逛了文创（总是被实用性阻止，毕竟我可是要四处流浪的人）。买了明信片，旁边姐妹盖的九层楼好几个盖坏了，我的一下子就盖好了，我可太棒了！6月15日寄出，6月24就到了，真的是很快！最后稍微逛了一下展馆，里面有复原的莫高窟和榆林窟，发觉听讲解真的是很必要了，因为真的不懂😅。差不多四个小时多点结束。小马弟弟去洗了车、鞋子、一堆衣服。瑞思拜，我都困死了。\n回去正是很热的时候，午饭想着去吃靖远尕六，排队要排到三点多，果断放弃去吃牛肉面了。下午照例睡觉😴。睡醒点了思露杏皮茶和螺蛳粉的外卖。冰的玫瑰牛奶鸡蛋醪糟和青稞甜醅，我觉得都很好喝，妈妈比较喜欢玫瑰味儿的醪糟。\n📍鸣沙山月牙泉\n因为我跟我妈在磨叽的吃饭，被小马弟弟催了好几次，七点钟才去。门口堵车，领队带我们绕了一下下，路过很多拍照的店就到了大门口。景区真的很多很多骆驼🐫，排成一队慢悠悠的走，还有的就在沙漠上休息。不知道为啥我并不是很想骑骆驼，更想看日落，和沙漠亲密接触，就直接上山了\n这次俺特地穿了拖鞋，但是也没用，夹脚拖真的不行❌，洞洞鞋应该比较方便不过我没有😮‍💨。上山一如既往的累，不敢想象玄奘取经经过沙漠怎么走的动。走到一半我觉得我不行了，上面已经很多人坐下了，我就也坐下，远远的看着月牙泉。看夕阳的话这天太阳并不算很好，下面全是云，最后只拍到太阳钻进了云层里，剩下一点点余晖。 身边很多打扮的漂漂亮亮的小姐妹们，在拍照，该说不说还是蛮养眼的。\n夜幕降临之后月牙泉和城市的灯光亮起，天也没那么热了，再待一会儿人变少了。我不愿意下去，又向上爬了一段距离，再高一点的地方有一些大学生在放五月天，引得认识的不认识的人都在跟着唱。这就是大学生的浪漫呀～我爱死浪漫！后来实在待的太久，领队催我下山去夜市逛吃，我说我都想住在这儿😊。\n十一点多才依依不舍告别沙漠，太晚太累，夜市就被表决取消了。\n留下一些遗憾，下次去弥补吧～\nDay 7 地上的彩虹 6.16\n敦煌去张掖大概是司机最煎熬的一天～起的很早，路程很长，朝着阳光开。小马弟弟甚至要吃一些槟榔提神。回来之后听播客里说，也门人随身备着嚼的一种草，也可以提神的。\n📍嘉峪关\n中午时分到了嘉峪关附近吃午饭。没有买门票只是在门口拍照留念。从大门口到检票口有一些距离，进去逛了一圈，有一些还没修建好的地方，和一大片茂盛的芦苇荡，一整块都是郁郁葱葱的 坐在柳树底下乘凉，旁边还有个大叔在大声睡觉💤哈哈，电话都没能吵醒他，真有意思。\n📍七彩丹霞\n从嘉峪关离开就是继续赶路。七彩丹霞到的比较晚，一开始进去还比较热但过了一会儿就不热了，多待一会儿还可以看夕阳，感觉时间特别好。照例看了很多攻略，第一站大部分人都下车了，我们没有下，直接去了第二站。\n太阳比较好，色彩也看得分明，感觉自己很幸运～听到有人说不应该在第一站浪费那么多时间的哈哈。一个成熟的景点就是每一个站点都标注的很清楚，路线都安排的明明白白。除了爬上站台就没有怎么走路，不热的话也不会觉得很累，逛的很舒适。印象最深的果然就还得是第四站，一开始远远的看到乌压压一片人是有点退缩的，所幸到了没有失望，是几个站点里最漂亮的。怪不得大家说最值得看的就是这个！到的时候也是阳光最灿烂的时候，没有网图那么鲜艳但也已经足够美。我觉得这样的自然总比加厚厚的滤镜好看多了。\n晚上住在七彩镇，住宿挺便宜的，条件也还行吧，镇子已经很好啦，旁边吃的很多，送的杏皮茶也很好喝，我狂炫！\n据说张掖好玩的地方很多，这次只是路过一下，有机会希望能好好玩一下～\nDay 8 迷雾中的草原 6.17\n预计九点钟出发，酒店早餐却只到八点，只能七点多爬起来吃饭再睡回笼觉😭。和领队已经培养出了默契，起床退房刚好看到他车开过来。\n看了好几天荒漠和戈壁，突然有了绿色大家都很高兴。彼此都熟悉了，路上说说笑笑放音乐，虽然是阴天气氛还挺愉悦的。山上有很多羊羊～有的羊羊为了便于区分被涂成五颜六色 可能是有山神滤镜，感觉黑牦牛又酷又好看还很神圣。\n在草原停留，天气又变得很凉，重新把冲锋衣焊在身上。看到很可爱的藏族小朋友，穿着藏族小衣服一摇一摆的走，脸蛋红扑扑的。大人说他还不会说普通话也听不懂我们在讲什么。跑到路对面去看溪流，这里好像随便一处水都很清澈。停留一会儿被小马弟弟一声长哨叫回去（震惊🤯好厉害的样子）。我说你要不喊我，我还要往更远的地方去呢！还想去和牦牛合照呢！\n午饭停在途中吃，目睹另一桌姐妹拆开一根淀粉肠都被制止了，原来清真饭馆不能有任何可能含有猪肉的东西。想想一路上吃的好像确实都是牛羊肉，也是蛮有意思的。\n不远就有很多当地人开的马场。草原被划分好，围上栏杆，所有房子都要报备好才能建起来。草原上到处都是兔鼠打的洞洞，这些可爱生物好像不太怕人，我可以站的很近看它吃草。但是又蹿的飞快，举我们四人之力也抓不到它。无所谓啦，真的很可爱，我拍了好多小视频～草原上有秋千，小马弟弟非要给我荡秋千，我兴致勃勃坐上去然后一路惊吓😅早知道此人不会如此好心💢。\n在草原上怎么能不骑马呢？我一早想感受在马上飞奔的感觉（尽管我知道会非常颠）。事实确实如此。一开始走得很慢，和牵马的人还说了两句话。然后小跑的时候我就已经非常紧张，手机都没敢拿，很怕自己一个不小心下去了。最后跑起来适应了一会儿莫名觉得好爽，可惜刚开始觉得爽就结束了。而且骑马五分钟，屁股疼两天哈哈。真希望有机会可以好好学会骑马自己骑！小马弟弟还问我害不害怕，笑话，这怎么可能害怕呢！\n路过一个很大的经幡，很漂亮，卖糯米做的隆达纸，草原上都是纸，空中也是纸，不好看但是浪漫。祈福用的嘛，祝愿大家都平平安安。作为一个非常不喜欢拍照的人，在这里被小马弟弟强制拍照了：最后一天不拍什么时候拍！\n再往前走过山路开始下雨，大家玩累了睡了，一路上只剩下雨声和车声。走过弯道，隧道，向西宁驶去。\n回程，依依不舍。\n路过有些稀疏的油菜花，看不到雪山，远处的草原也被迷雾笼罩了。阴雨天，看什么都打了折扣，看到的草原其实也并不漂亮。但也不是什么都没干，还是留下了特别的回忆～这就够啦。\n回西宁买了一些吃的带回家。辣椒，牦牛肉干，葡萄干和奶条奶片，我都好喜欢呀！如果项目真能被分到青海就好了！最后去吃了手抓羊肉（鲜嫩！），特色的面片 (和河南的不一样)，后来才知道那是尕面片呀，尽管不饿还是吃了一大碗！碗子喝茶加冰糖也很有趣。\n小马弟弟请客了，我说要请回来，一定要请回来的，就是不知道何年何月了。\n买了卧铺票返程，旅程再快乐，终究是要结束啦。\nDay 9 回程感悟 躺在晃晃悠悠的小火车上，其实我心里很不是滋味的，太开心了一点都不想离开。就像一场梦要醒了，就像一段感情走到尽头了。放纵自己发泄情绪。想想也觉得自己蛮可笑的，才一个星期而已呀！只能说明我确实太喜欢这个地方吧。这里的一草一木，雪山，旷野，荒漠，人，都散发着自由的味道，是被规训了二十多年的我梦寐以求的东西。\n西北真的是我非常喜欢的地方，短短几天足以令我魂牵梦萦。也许某一天我会搬去西宁小住，停留在这个空旷自由之地久一点，再久一点。\n","permalink":"https://oooldgreen.github.io/posts/travel/northwest230610/","summary":"\u003cp\u003e算算6月18日从西北回来已经有两周了，念念不忘，整理了许多照片，发了小红书，当然也要记录在我的网页里，可以写大段的文字才更爽啊～\u003c/p\u003e","title":"青甘大环线游记"},{"content":"一转眼两个多月没维护自己的小网站了，符合我三天打鱼两天晒网的调调，不过到底舍不得，一直记挂着。\n毕业的事情终于也忙的差不多了，缓了两天，吃了散伙饭，才终于有了些实感，整个人松了口气。\n行李收拾的差不多了，一抬眼寝室里的人也都走的差不多了，不少人打算再回来，毕竟还要拿毕业证不是。我没留时间给这个活动了，策划了好久的旅游，之后大概会在这里写游记吧。\n很久没更新前端的东西了，为啥呢？一是忙，二是没找到前端工作呗。不知道以后还会不会继续学习了，虽然我还有点想。可能会学的更博更广不局限在前端吧。（希望上班了我还能有精力学习啊，应该能有吧😂）\n想做的事情毕竟太多了，写博客，写小说，学吉他，学摄像\u0026hellip;二十多岁的年纪，以后要把想做的一一试过去。\n留给武汉的日子不多了，学校大概不太会想念，城市也就那样，漂泊的人看哪里都能是家。唯一不舍得的就是那些人了吧，虽然也就那么一两个。不过管她呢，走到哪里都会认识新的朋友。\n挺开心的，回去能继续弹我的吉他了，把剩了三年的画画课画完，跟妈妈一起到处玩玩，收拾心情开始下一段旅程。\n要说遗憾的，也就是没能去做义工吧，时间来不及了，七年的心愿又不知道啥时候能实现了。\n我现在正吃着一颗葡萄🍇，好酸呐，想起来毕业答辩的时候给老师买的水果那叫一个甜啊，就没吃过这么好吃的蓝莓和葡萄，还带着玫瑰香气儿的。后面我们一起骂企业专家，有几个学生通宵大改，拖了四五天终于给签下了字儿，这临门一脚也是不容易。都过了就挺好的。\n漫无目的写了一大篇了，睡觉😴去了，附上一张鱼丸吧，自从看了浪姐3和乐海老喜欢了，有才华有顽固天真。\n学习，流浪，做梦。\n希望以后的日子里能越来越自由吧。\n","permalink":"https://oooldgreen.github.io/posts/daily/endof-school-life/","summary":"一转眼两个多月没维护自己的小网站了，符合我三天打鱼两天晒网的调调，不过到底舍不得，一直记挂着。\n毕业的事情终于也忙的差不多了，缓了两天，吃了散伙饭，才终于有了些实感，整个人松了口气。\n行李收拾的差不多了，一抬眼寝室里的人也都走的差不多了，不少人打算再回来，毕竟还要拿毕业证不是。我没留时间给这个活动了，策划了好久的旅游，之后大概会在这里写游记吧。\n很久没更新前端的东西了，为啥呢？一是忙，二是没找到前端工作呗。不知道以后还会不会继续学习了，虽然我还有点想。可能会学的更博更广不局限在前端吧。（希望上班了我还能有精力学习啊，应该能有吧😂）\n想做的事情毕竟太多了，写博客，写小说，学吉他，学摄像\u0026hellip;二十多岁的年纪，以后要把想做的一一试过去。\n留给武汉的日子不多了，学校大概不太会想念，城市也就那样，漂泊的人看哪里都能是家。唯一不舍得的就是那些人了吧，虽然也就那么一两个。不过管她呢，走到哪里都会认识新的朋友。\n挺开心的，回去能继续弹我的吉他了，把剩了三年的画画课画完，跟妈妈一起到处玩玩，收拾心情开始下一段旅程。\n要说遗憾的，也就是没能去做义工吧，时间来不及了，七年的心愿又不知道啥时候能实现了。\n我现在正吃着一颗葡萄🍇，好酸呐，想起来毕业答辩的时候给老师买的水果那叫一个甜啊，就没吃过这么好吃的蓝莓和葡萄，还带着玫瑰香气儿的。后面我们一起骂企业专家，有几个学生通宵大改，拖了四五天终于给签下了字儿，这临门一脚也是不容易。都过了就挺好的。\n漫无目的写了一大篇了，睡觉😴去了，附上一张鱼丸吧，自从看了浪姐3和乐海老喜欢了，有才华有顽固天真。\n学习，流浪，做梦。\n希望以后的日子里能越来越自由吧。","title":"毕业"},{"content":"天气好起来啦，一年中最爱的温度，空气不再冷冽，晚风不再具有攻击性，温柔的拂过脸庞，只是在晚风中散步就很幸福。\n学校的樱花渐次开放，有的已经开得繁盛，有的还零零落落。庆幸昨天下午抓住最后一点阳光，从实验室走出来的时候，天色还不晚，看到人烟，看到春天。想在下周周末去东湖看樱花。但是天气预报显示下周周末下雨降温。若是这样，就得盼望下下周樱花还开得繁盛啦。从上海到武汉，每一年樱花季都尽量不错过，就算疫情加下雨都预约了去武汉看樱花。这是疫情之后第一次看樱花，希望能如愿呀！\n看了兰心和羊驼玩耍的 vlog，灿烂的阳光，可爱的羊驼妈妈和羊驼宝宝，她的笑容也很灿烂，真好呀。\n周末放假终于过完了潜海季的任务。本来已经很困了，从海底救出队员伴着鱼群游向水面的时候很感动。\n最近在听小霞，我的美丽，缓解面试的焦虑，找到平和的自我。\n午后温暖的阳光，雨后斑斓的彩虹，斑驳的树影，金色的夕阳，你看我看的这个世界，多么美丽。\n","permalink":"https://oooldgreen.github.io/posts/daily/sakura2023/","summary":"天气好起来啦，一年中最爱的温度，空气不再冷冽，晚风不再具有攻击性，温柔的拂过脸庞，只是在晚风中散步就很幸福。\n学校的樱花渐次开放，有的已经开得繁盛，有的还零零落落。庆幸昨天下午抓住最后一点阳光，从实验室走出来的时候，天色还不晚，看到人烟，看到春天。想在下周周末去东湖看樱花。但是天气预报显示下周周末下雨降温。若是这样，就得盼望下下周樱花还开得繁盛啦。从上海到武汉，每一年樱花季都尽量不错过，就算疫情加下雨都预约了去武汉看樱花。这是疫情之后第一次看樱花，希望能如愿呀！\n看了兰心和羊驼玩耍的 vlog，灿烂的阳光，可爱的羊驼妈妈和羊驼宝宝，她的笑容也很灿烂，真好呀。\n周末放假终于过完了潜海季的任务。本来已经很困了，从海底救出队员伴着鱼群游向水面的时候很感动。\n最近在听小霞，我的美丽，缓解面试的焦虑，找到平和的自我。\n午后温暖的阳光，雨后斑斓的彩虹，斑驳的树影，金色的夕阳，你看我看的这个世界，多么美丽。","title":"Sakura"},{"content":"交换礼物的时候抱着一种好奇心，很好奇会收到怎么样的礼物。再加上寒假早早的回家又让我与礼物擦肩而过，去拿礼物时真的已经迫不及待啦。\n结果果然出乎我的意料！\n没有想到能够在快结束寝室生活的时候，能和朋友们用正宗的宽敞的电火锅一起在宿舍吃上一顿火锅：）\n自己煮火锅最大的好处就是经济实惠啦，肉可以吃到爽！鸳鸯锅真的很幸福！家里的电锅都不能煮鸳鸯锅的！买的番茄汤底意外的很棒，所有的食材煮进去都别有风味～\n而且我发现这样的不粘锅竟然蛮好刷的。由于很讨厌刷碗，这种多油的锅根本没碰过，还和室友学到了刷油锅的小技巧～已经能够想象以后一个人也可以煮火锅的幸福日子啦～\n由于拖延，都已经过去了三天才记录下来。也打算给寄给我礼物的小伙伴发一封邮件表达我的感谢和惊喜啦（虽然真的过了蛮久了😮‍💨。希望她看见也能开心😊。\n最后是周末的晚上和同门小伙伴一起吃的牛蛙～迟来的庆祝奖学金的发放，也祝愿我们都能够顺利毕业，前程似锦～\n🌸 最最后，希望今年看樱花的时候是个好天气呀 🌸\n","permalink":"https://oooldgreen.github.io/posts/daily/christmas-santa-2022/","summary":"交换礼物的时候抱着一种好奇心，很好奇会收到怎么样的礼物。再加上寒假早早的回家又让我与礼物擦肩而过，去拿礼物时真的已经迫不及待啦。\n结果果然出乎我的意料！\n没有想到能够在快结束寝室生活的时候，能和朋友们用正宗的宽敞的电火锅一起在宿舍吃上一顿火锅：）\n自己煮火锅最大的好处就是经济实惠啦，肉可以吃到爽！鸳鸯锅真的很幸福！家里的电锅都不能煮鸳鸯锅的！买的番茄汤底意外的很棒，所有的食材煮进去都别有风味～\n而且我发现这样的不粘锅竟然蛮好刷的。由于很讨厌刷碗，这种多油的锅根本没碰过，还和室友学到了刷油锅的小技巧～已经能够想象以后一个人也可以煮火锅的幸福日子啦～\n由于拖延，都已经过去了三天才记录下来。也打算给寄给我礼物的小伙伴发一封邮件表达我的感谢和惊喜啦（虽然真的过了蛮久了😮‍💨。希望她看见也能开心😊。\n最后是周末的晚上和同门小伙伴一起吃的牛蛙～迟来的庆祝奖学金的发放，也祝愿我们都能够顺利毕业，前程似锦～\n🌸 最最后，希望今年看樱花的时候是个好天气呀 🌸","title":"礼物"},{"content":"餐馆列表页 首先在 ShopList.vue 中将单纯的列表改为路由跳转\n1 2 3 \u0026lt;ul v-load-more=\u0026#34;loaderMore\u0026#34; type=\u0026#34;1\u0026#34; v-if=\u0026#34;shopList.length\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;shop\u0026#39;, query: { geohash, id: item.id} }\u0026#34; class=\u0026#34;shop-info\u0026#34; v-for=\u0026#34;item in shopList\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; \u0026lt;/ul\u0026gt; 父子页面跳转，父页面隐藏 路由 index.js ，添加 showPage 控制页面的显示与隐藏：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const routes = [ { path: \u0026#39;/shop\u0026#39;, component: Shop, children: [ { path: \u0026#39;shopDetail\u0026#39;, component: ShopDetail, meta: { showPage: false } } ], meta: { showPage: true } } ] 父页面 Shop.vue 中需要添加 router-view 显示子页面\n1 2 3 4 5 6 7 8 \u0026lt;!-- 父页面 --\u0026gt; \u0026lt;!-- 添加 v-show 控制隐藏 --\u0026gt; \u0026lt;section v-show=\u0026#34;$route.meta.showPage\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;!-- 子路由显示的区域 --\u0026gt; \u0026lt;!-- 后面要给页面加进入动画，所以用 transition 包裹 --\u0026gt; \u0026lt;transition\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt; 子页面显示动画 页面从右侧进入动画 1 2 3 \u0026lt;transition name=\u0026#34;router-slide\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/transition\u0026gt; 在 style 中添加动画\n1 2 3 4 5 6 7 8 9 10 .router-slide-enter-active, .router-slide-leave-active { transition: all .3s; transform: translateX(0); opacity: 0; } .router-slide-enter, .router-slide-leave-to { transform: translateX(100%); } 渐变消失出现动画 1 2 3 \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;section class=\u0026#34;license-img-container\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;/transition\u0026gt; 在 style 中添加动画\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .fade-enter-active, .fade-leave-active { transition: all .3s; opacity: 1; } .fade-enter, .fade-leave-to { opacity: 0; } .license-img-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .5); } 点击‘\u0026hellip;’出现提示气泡效果 气泡效果如下图： 制作方法是内容为一个矩形盒子，右上角小三角是加伪元素 ::after，做一个正方形旋转45度再定位得来。代码如下（样式用scss写的）：\n1 2 3 4 5 6 7 \u0026lt;header class=\u0026#34;menu-list-header\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;menu-header-right\u0026#34; @click=\u0026#34;showMenuDes(index)\u0026#34;\u0026gt;...\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;menu-header-des-tip\u0026#34; v-if=\u0026#34;showMenuDesIndex == index\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{item.name}}\u0026lt;/span\u0026gt; {{item.description}} \u0026lt;/div\u0026gt; \u0026lt;/header\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 .menu-list-header { .menu-header-right { color: #666; padding-right: 0.5rem; } .menu-header-des-tip { position: absolute; top: 1.7rem; right: 0.5rem; width: 65%; background-color: #39373a; opacity: 0.9; font-size: 0.7rem; color: #fff; border-radius: 0.3rem; padding: 0.6rem 0.5rem 0.6rem; span { color: #fff; font-size: 0.8rem; font-weight: bold; margin-right: 0.3rem; } \u0026amp;::after { content: \u0026#39;\u0026#39;; position: absolute; top: -0.2rem; right: 0.18rem; background-color: #39373a; width: 0.7rem; height: 0.7rem; transform: rotate(45deg); } } } js代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 data() { return { showMenuDesIndex: null, // 显示菜单标题描述 } }, methods: { showMenuDes(index) { if(this.showMenuDesIndex == index) { this.showMenuDesIndex = null } else { this.showMenuDesIndex = index } } } 后面“新品”标识也可以这样做，将正方形方块旋转45度定位到商品盒子右上角，隐藏溢出即可\n食品详情页面 目标功能 定位功能 选择城市 搜索地址 展示所选地址附近商家列表 搜索美食 根据距离、销量、评分、特色菜、配送方式等进行排序和筛选 餐馆视频列表页 单个食品详情页面 ","permalink":"https://oooldgreen.github.io/posts/frontend/vue2-elm-day5/","summary":"餐馆列表页 首先在 ShopList.vue 中将单纯的列表改为路由跳转\n1 2 3 \u0026lt;ul v-load-more=\u0026#34;loaderMore\u0026#34; type=\u0026#34;1\u0026#34; v-if=\u0026#34;shopList.length\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;shop\u0026#39;, query: { geohash, id: item.id} }\u0026#34; class=\u0026#34;shop-info\u0026#34; v-for=\u0026#34;item in shopList\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; \u0026lt;/ul\u0026gt; 父子页面跳转，父页面隐藏 路由 index.js ，添加 showPage 控制页面的显示与隐藏：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const routes = [ { path: \u0026#39;/shop\u0026#39;, component: Shop, children: [ { path: \u0026#39;shopDetail\u0026#39;, component: ShopDetail, meta: { showPage: false } } ], meta: { showPage: true } } ] 父页面 Shop.","title":"Vue2 Elm Day5"},{"content":"时光如梭，一眨眼年就过完了。\n这一个多月经历了很多，阳了，以为是无症状，结果还是烧了，阴了，又皮炎了；因为皮炎好吃的爱吃的全都不能吃，吃的药还让我足足吐了一晚上；拒了我仅有的俩offer，一切从头开始；憋了一个月多的论文，总算写完了，不敢出去玩，只去山上玩了一天；学会了飞无人机，还没来的及好好玩就回学校了；拒绝了同学聚会，和好姊妹和发小吃了两次饭，看了电影深海，据说是春节档最好看的；看了好多年没举办过的舞龙，看了长大后再也没看过的但是记忆里最漂亮的烟花秀，不过都是市民自己放的。\n本命年的开端迷茫又忙碌又好像什么都没忙，一晃神开学了又要每天来实验室了，普通话都觉得说不太利索了，夹杂了好多方言习惯；走在路上努力回想来学校的地铁流程，恍惚连门牌号都不太记得了，仿佛这三年不存在一般。很想快点毕业，又不知道毕业能去哪里，我会在哪里流浪？我会过的快乐吗？我能实现梦想吗？眼前的事情都很急迫，脑子却早已漂浮到外太空，身边的一切仿佛都不是真实。可能大脑放了太久的假，一时之间找不到在哪里。\n新一年的计划已经写好，未来三年的计划也在脑袋里盘旋又盘旋，所求不过健康安乐自由。继续学习，直到学不动；继续看世界，直到再也看不到。\n","permalink":"https://oooldgreen.github.io/posts/daily/hello2023/","summary":"时光如梭，一眨眼年就过完了。\n这一个多月经历了很多，阳了，以为是无症状，结果还是烧了，阴了，又皮炎了；因为皮炎好吃的爱吃的全都不能吃，吃的药还让我足足吐了一晚上；拒了我仅有的俩offer，一切从头开始；憋了一个月多的论文，总算写完了，不敢出去玩，只去山上玩了一天；学会了飞无人机，还没来的及好好玩就回学校了；拒绝了同学聚会，和好姊妹和发小吃了两次饭，看了电影深海，据说是春节档最好看的；看了好多年没举办过的舞龙，看了长大后再也没看过的但是记忆里最漂亮的烟花秀，不过都是市民自己放的。\n本命年的开端迷茫又忙碌又好像什么都没忙，一晃神开学了又要每天来实验室了，普通话都觉得说不太利索了，夹杂了好多方言习惯；走在路上努力回想来学校的地铁流程，恍惚连门牌号都不太记得了，仿佛这三年不存在一般。很想快点毕业，又不知道毕业能去哪里，我会在哪里流浪？我会过的快乐吗？我能实现梦想吗？眼前的事情都很急迫，脑子却早已漂浮到外太空，身边的一切仿佛都不是真实。可能大脑放了太久的假，一时之间找不到在哪里。\n新一年的计划已经写好，未来三年的计划也在脑袋里盘旋又盘旋，所求不过健康安乐自由。继续学习，直到学不动；继续看世界，直到再也看不到。","title":"开 学 啦！"},{"content":"从 Msite 导航进入的商家列表 从 url 得到点击的分类 id 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;router-link v-for=\u0026#34;foodItem in item\u0026#34; :key=\u0026#34;foodItem.id\u0026#34; :to=\u0026#34;{ path: \u0026#39;/food\u0026#39;, query: { geohash, title: foodItem.title, restaurantCateId: getCateId(foodItem.link) } }\u0026#34; \u0026gt;\u0026lt;/router-link\u0026gt; 1 2 3 4 5 6 7 8 9 // 得到餐厅分类id getCateId(url) { let urlData = decodeURIComponent(url.split(\u0026#39;=\u0026#39;)[1].replace(\u0026#39;\u0026amp;target_name\u0026#39;,\u0026#39;\u0026#39;)); if (/restaurant_category_id/gi.test(urlData)) { return JSON.parse(urlData).restaurant_category_id.id } else { return \u0026#39;\u0026#39; } } 下拉菜单制作 CSS 类的动态选择 可以使用 计算属性 或者 通过模版代码孔氏是否添加CSS样式\n方法一：计算属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;section :class=\u0026#34;category_active\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { attachRed: false } } computed: { category_active: function () { return { red: this.attachRed, grey: !this.attachRed } } } } \u0026lt;/script\u0026gt; 方法二：模版代码 1 2 3 \u0026lt;template\u0026gt; \u0026lt;section :class=\u0026#34;{ category_active: restaurant_category_id == item.id }\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;/template\u0026gt; CSS 超出部分滑动显示 设置高度，并设置 overflow 即可实现超出的部分滑动\n1 2 3 4 .cate-right { height: 27rem; overflow: auto; } 下拉菜单隐藏显示 点击图标旋转，小三角旋转 180 度，变成蓝色\n1 2 3 4 5 .sort-svg { transform: rotate(180deg); transition: all .3s; fill: $blue } 使用 transition 标签实习点击显示隐藏菜单\n1 2 3 4 5 6 7 \u0026lt;!-- html部分 --\u0026gt; \u0026lt;section @click=\u0026#34;chooseType(\u0026#39;food\u0026#39;)\u0026#34;\u0026gt; \u0026lt;transition name=\u0026#34;showlist\u0026#34;\u0026gt; \u0026lt;!-- 菜单内容 --\u0026gt; \u0026lt;section v-show=\u0026#34;sortBy===\u0026#39;food\u0026#39;\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/section\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 /* css部分 */ /* 平滑过渡效果 */ .showlist-enter-active, .showlist-leave-active { transition: all .3s; transform: tranlateY(0); } .showlist-enter, .showlist-leave-to { opacity: 0; transform: translateY(-100%); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // js部分 data() { return { sortBy: \u0026#39;\u0026#39;, } } methods: { // 判断点击菜单类型，按类型显示菜单 chooseType(type) { // console.log(type) // 当sorBy无值，菜单显示；当sortBy有值，隐藏菜单 if (this.sortBy !== type) { this.sortBy = type } else { this.sortBy = \u0026#39;\u0026#39; } } } 补充根据属性值获取商家数据 在 Food.vue 中给 shoplist 传递分类数据\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div class=\u0026#34;shop-list\u0026#34;\u0026gt; \u0026lt;ShopList :restaurantCateId=\u0026#34;restaurantCateId\u0026#34; :geohash=\u0026#34;geohash\u0026#34; :restaurantCateIds=\u0026#34;restaurantCateIds\u0026#34; :sortByType=\u0026#34;sortByType\u0026#34; :deliveryMode=\u0026#34;deliveryMode\u0026#34; :confirmSelect=\u0026#34;confirmSelect\u0026#34; :supportIds=\u0026#34;support_ids\u0026#34; v-if=\u0026#34;latitude\u0026#34;\u0026gt; \u0026lt;/ShopList\u0026gt; \u0026lt;/div\u0026gt; 在 ShopList.vue 中按照分类数据重新请求商家列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 export default { props: [\u0026#39;restaurantCateId\u0026#39;, \u0026#39;restaurantCateIds\u0026#39;, \u0026#39;sortByType\u0026#39;, \u0026#39;deliveryMode\u0026#39;, \u0026#39;supportIds\u0026#39;, \u0026#39;confirmSelect\u0026#39;, \u0026#39;geohash\u0026#39;], methods: { // 属性值发生变化时重新请求商家列表 async changeProp() { // 加载等待 this.showLoading = true this.offset = 0 // 重新请求数据 let res = await shopList(this.latitude, this.longitude, this.offset, \u0026#39;\u0026#39;, this.restaurantCateIds, this.sortByType, this.deliveryMode, this.supportIds) this.hideLoading() // 考虑到本地模拟数据是引用类型，所以返回一个新的数组 this.shopList = [...res] } }, watch: { // 监听几个参数的改变，一旦发生变化按照属性值重新获取数据 restaurantCateIds: function (value) { this.changeProp() }, // 监听排序方式的改变 sortByType: function (value) { this.changeProp() }, // 监听确认按钮点击 confirmSelect: function (value) { this.changeProp() } } } 筛选 菜单布局分三部分，配送方式、商家属性和清空确认按钮；\n用户选择配送方式和商家属性后根据选择进行商铺筛选，用户选中的选项前面的图标会变为对勾✅，字体颜色变为蓝色；\n在确认按钮部分会出现计数；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;transition name=\u0026#34;showlist\u0026#34;\u0026gt; \u0026lt;section v-show=\u0026#34;sortBy==\u0026#39;activity\u0026#39;\u0026#34; class=\u0026#34;sort-detail-type activity-container\u0026#34;\u0026gt; \u0026lt;section style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;activity-header\u0026#34;\u0026gt;配送方式\u0026lt;/header\u0026gt; \u0026lt;ul class=\u0026#34;activity-filter\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;filter-li\u0026#34; v-for=\u0026#34;(item, index) in this.delivery\u0026#34; :key=\u0026#34;index\u0026#34; @click=\u0026#34;selectDeliveryMode(item.id)\u0026#34;\u0026gt; \u0026lt;svg :style=\u0026#34;{ opacity: (item.id == 0) \u0026amp;\u0026amp; (delivery_mode !==0) ? \u0026#39;0\u0026#39; : \u0026#39;1\u0026#39; }\u0026#34;\u0026gt; \u0026lt;use xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; :xlink:href=\u0026#34;deliveryMode == item.id ? \u0026#39;#selected\u0026#39; : \u0026#39;#fengniao\u0026#39;\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;span :class=\u0026#34;{ select_filter: deliveryMode == item.id }\u0026#34;\u0026gt;{{item.text}}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;activity-header\u0026#34;\u0026gt;商家属性（可以多选）\u0026lt;/header\u0026gt; \u0026lt;ul class=\u0026#34;activity-filter\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;filter-li\u0026#34; v-for=\u0026#34;(item, index) in this.activity\u0026#34; :key=\u0026#34;index\u0026#34; @click=\u0026#34;selectSupportIds(index, item.id)\u0026#34;\u0026gt; \u0026lt;svg v-show=\u0026#34;supportIds[index].status\u0026#34;\u0026gt; \u0026lt;use xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; xlink:href=\u0026#34;#selected\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;span v-show=\u0026#34;!supportIds[index].status\u0026#34; class=\u0026#34;filter-icon\u0026#34; :style=\u0026#34;{ color: \u0026#39;#\u0026#39; + item.icon_color, borderColor: \u0026#39;#\u0026#39; + item.icon_color}\u0026#34; \u0026gt;{{item.icon_name}}\u0026lt;/span\u0026gt; \u0026lt;span :class=\u0026#34;{ selecter_filter: supportIds[index].status}\u0026#34;\u0026gt;{{item.name}}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;activity-btn\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;clear-btn\u0026#34; @click=\u0026#34;clearAll()\u0026#34;\u0026gt;清空\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;confirm-btn clear-btn\u0026#34; @click=\u0026#34;confirmSelect()\u0026#34;\u0026gt; 确认 \u0026lt;span v-show=\u0026#34;this.filterNum!==0\u0026#34; style=\u0026#34;color: #fff\u0026#34;\u0026gt;({{this.filterNum}})\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/transition\u0026gt; 点击配送方式和商家属性，根据相应索引和 id 计算选择项个数 filterNum，控制选择项文本颜色和图标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 selectDeliveryMode(id) { if (this.deliveryMode === null) { this.filterNum++ this.deliveryMode = id } else if(this.deliveryMode == id) { this.filterNum-- this.deliveryMode = null } else { this.deliveryMode = id } }, selectSupportIds(index, id) { // status 为 true 时所选项图标变为 对号，为 false 时显示图标 // 数组替换新的值 this.supportIds.splice(index, 1, { status: !this.supportIds[index].status, id }) // 遍历 重新计算filterNum this.filterNum = this.deliveryMode==null ? 0 : 1 this.supportIds.forEach(item =\u0026gt; { if (item.status) { this.filterNum++ } }) } 点击清空按钮还原菜单栏，清空选项；点击确认按钮收起菜单栏，重新请求商铺。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 clearAll() { // 清空选择个数 this.filterNum = 0 // 配送方式清空 this.deliveryMode = null // 商家属性 status 置为 false this.supportIds.forEach(item =\u0026gt; { item.status = false }) }, confirmSelect() { // confirmStatus 状态转变时会重新进行数据请求 this.confirmStatus = !this.confirmStatus // sortBy 为空时收起菜单 this.sortBy = \u0026#39;\u0026#39; } 在 ShopList.vue 中监听 confirmStatus 的变化，从而进行重新请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 watch: { confirmSelect: function (value) { // confirmSelect 改变即调用 changeProp this.changeProp() } } methods: { async changeProp() { // 出现等待加载界面 this.showLoading = true // 页面回到顶端 this.offset = 0 // 根据参数重新请求数据 let res = await shopList(this.latitude, this.longitude, this.offset, \u0026#39;\u0026#39;, this.restaurantCateIds, this.sortByType, this.deliveryMode, this.supportIds) // 考虑到本地模拟数据是引用类型，所以返回一个新的数组 this.shopList = [...res] // console.log(this.shopList) if (res.length \u0026lt; 20) { this.touchend = true } // 隐藏等待加载界面 this.hideLoading() } } 目标功能 定位功能 选择城市 搜索地址 展示所选地址附近商家列表 搜索美食 根据距离、销量、评分、特色菜、配送方式等进行排序和筛选 ","permalink":"https://oooldgreen.github.io/posts/frontend/vue2-elm-day4/","summary":"从 Msite 导航进入的商家列表 从 url 得到点击的分类 id 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;router-link v-for=\u0026#34;foodItem in item\u0026#34; :key=\u0026#34;foodItem.id\u0026#34; :to=\u0026#34;{ path: \u0026#39;/food\u0026#39;, query: { geohash, title: foodItem.title, restaurantCateId: getCateId(foodItem.link) } }\u0026#34; \u0026gt;\u0026lt;/router-link\u0026gt; 1 2 3 4 5 6 7 8 9 // 得到餐厅分类id getCateId(url) { let urlData = decodeURIComponent(url.split(\u0026#39;=\u0026#39;)[1].replace(\u0026#39;\u0026amp;target_name\u0026#39;,\u0026#39;\u0026#39;)); if (/restaurant_category_id/gi.test(urlData)) { return JSON.parse(urlData).restaurant_category_id.id } else { return \u0026#39;\u0026#39; } } 下拉菜单制作 CSS 类的动态选择 可以使用 计算属性 或者 通过模版代码孔氏是否添加CSS样式","title":"Vue2 Elm 项目记录 Day4"},{"content":"第三天啦，加油！\n数据处理 需要处理数据将数组分成 8 个一组，方便后面引入 Swiper 的分页器效果\n1 2 3 4 5 msiteFood(geohash).then(res =\u0026gt; { while (res.length !== 0) { this.foodCate.push(res.splice(0, 8)) } }) 处理前返回的结果: 处理后的数组: 使用 Swiper 在 Vue 中使用Swiper Swiper 文档 先安装 Swiper\n1 npm install swiper --save-dev 根据文档在组件中引入 Swiper 的 js 和 css，引入 Swiper 只有基础模块，如果需要其他组件功能需要另外引用，最后在 mounted 中初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // msite.vue // 引入 js import Swiper, { Pagination } from \u0026#39;swiper\u0026#39; // 引入 css import \u0026#39;swiper/css\u0026#39; import \u0026#39;swiper/css/pagination\u0026#39; export default { components: { Swiper, SwiperSlide }, mounted() { // 引入 Swiper const swiper = new Swiper(\u0026#39;.swiper\u0026#39;, { modules: [Pagination] }) } } 调试很久，报错 swiper is not a constructor，看到另一篇博客也有说这种报错，解决方法就是直接本地引入 js 和 css：\n1 2 import \u0026#39;src/plugins/swiper.min.js\u0026#39; import \u0026#39;src/style/swiper.min.css\u0026#39; 但即使不再报错，我的 Pagination 还是没有显示，试了一下分页功能可以正常拖动，检查 swiper-pagination 中没有小圆点元素。检查我的 Swiper 版本： 所以直到把初始化 Swiper 的写法改成下面这样，小圆点才出来，无语住了\n1 2 3 new Swiper(\u0026#39;.swiper-container\u0026#39;, { pagination: \u0026#39;.swiper-pagination\u0026#39; }) 上拉加载功能 上拉加载的实现就是在页面开始滑动时获取高度，在页面停止滑动后监听计算页面是否到达底部，触底则进行动作\ntouchstart: 运动开始时获取元素 touchmove: 监听 scrollTop 是否到达底部 touchend: 运动结束时判断是否有惯性动作，惯性动作结束后判断是否到达底部 功能实现需要获取元素 padding 值和 margin 值，所以将用于获取 style 属性值的方法提取出来：\n1 2 3 4 5 6 7 8 9 10 11 12 export const getStyle = ((ele, attr, NumberNode=\u0026#39;int\u0026#39;) =\u0026gt; { let target if (attr === \u0026#39;scrollTop\u0026#39;) { target = ele.scrollTop } else if (ele.currenStyle) { target = ele.currenStyle[attr] } else { target = document.defaultView.getComputedStyle(ele.null)[attr] } // 获取 opacity 需要获取小数 return NumberNode == \u0026#39;float\u0026#39; ? parseFloat(target) : parseInt(target) }) 上拉加载功能的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 export const loadMore = { directives: { \u0026#39;load-more\u0026#39;: { bind: (el, binding) =\u0026gt; { let windowHeight = window.screen.height let height let setTop let paddingBottom let marginBottom let requestFram let oldScrollTop let scrollEl let heightEl let scrollType = el.attributes.type \u0026amp;\u0026amp; el.attributes.type.value let scrollReduce = 2 if (scrollType === 2) { scrollEl = el heightEl = el.children[0] } else { scrollEl = document.body heightEl = el } // 运动开始时获取元素：高度、offsetTop、padding、margin el.addEventListener(\u0026#39;touchstart\u0026#39;, () =\u0026gt; { height = heightEl.clientHeight if (scrollType === 2) { height = height } setTop = el.offsetTop paddingBottom = getStyle(el, \u0026#39;paddingBottom\u0026#39;) marginBottom = getStyle(el, \u0026#39;marginBottom\u0026#39;) }, false) // 监听 scrollTop 的值是否到达底部 el.addEventListener(\u0026#39;touchmove\u0026#39;, () =\u0026gt; { loadMore() }, false) // 运动结束时判断是否有惯性动作，惯性动作结束后判断是否到达底部 el.addEventListener(\u0026#39;touchend\u0026#39;, () =\u0026gt; { oldScrollTop = scrollEl.scrollTop moveEnd() }, false) const moveEnd = () =\u0026gt; { requestFram = requestAnimationFrame(() =\u0026gt; { if (scrollEl.scrollTop !== oldScrollTop) { oldScrollTop = document.body.scrollTop loadMore() moveEnd() } else { cancelAnimationFrame(requestFram) // 为了防止鼠标抬起时已经渲染好数据从而导致重获取数据，重新获取dom高度 height = heightEl.clientHeight loadMore() } }) } // 判断是否到达底部 const loadMore = () =\u0026gt; { if (document.body.scrollTop + windowHeight \u0026gt;= height + setTop + paddingBottom + marginBottom - scrollReduce) { binding.value() } } } } } } 在组件中使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul v-load-more=\u0026#34;loaderMore\u0026#34;\u0026gt; \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p class=\u0026#34;touchend\u0026#34; v-if=\u0026#34;touchend\u0026#34;\u0026gt;没有更多了\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { loadMore } from \u0026#39;../../../config/mUtils\u0026#39; export default { data() { return { offset: 0, shopList: [], touchend: false, // 没有更多数据 showLoading: true, // 显示加载动画 preventRepeatRequest: false, // 防止重复加载 } }, mixins: [loadMore], methods: { async loaderMore () { if (this.touchend) { return } if (this.preventRepeatRequest) { return } // 展示loading this.showLoading = true this.preventRepeatRequest = true // 再加载20条数据 this.offset += 20 let res = await shopList(this.latitude, this.longitude, this.offset, this.restaurantCategoryId) // 隐藏loading this.hideLoading() // 扩展shopList this.shopList = [...this.shopList, ...res] // 获取数据小于2-，表明没有更多数据了 if(res.length \u0026lt; 20) { this.touchend = true } this.preventRepeatRequest = false } \u0026lt;/script\u0026gt; 返回顶部功能 返回顶部函数，只要文本高度大于 500，显示返回顶部按钮（在 callback 中自定义）\n1 2 3 4 5 6 7 const showBackFun = () =\u0026gt; { if (document.body.scrollTop \u0026gt; 500) { cb(true) } else { cb(false) } } 完整代码是在开始、结束、运动都对页面所在的位置进行判断决定是否显示按钮\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 export const showBack = cb =\u0026gt; { let requestFram let oldScrollTop document.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { showBackFun() }, false) document.addEventListener(\u0026#39;touchstart\u0026#39;, () =\u0026gt; { showBackFun() }, false) document.addEventListener(\u0026#39;touchmove\u0026#39;, () =\u0026gt; { showBackFun() }, { passive: true }) document.addEventListener(\u0026#39;touchend\u0026#39;, () =\u0026gt; { oldScrollTop = document.body.scrollTop moveEnd() }, { passive: true }) const moveEnd = () =\u0026gt; { requestFram = requestAnimationFrame(() =\u0026gt; { if (document.body.scrollTop !== oldScrollTop) { oldScrollTop = document.body.scrollTop moveEnd() } else { cancelAnimationFrame(requestFram) } }) showBackFun() } const showBackFun = () =\u0026gt; { if (document.body.scrollTop \u0026gt; 500) { cb(true) } else { cb(false) } } } 在需要使用的组件的 mounted 中挂载\n1 2 3 4 5 6 7 8 9 10 11 12 import { showBack } from \u0026#39;../../../config/mUtils\u0026#39; export default { data: { showBackTop: false // 显示返回顶部按钮 }, mounted: { showBack(status =\u0026gt; { this.showBackTop = status }) } } 创建返回顶部 svg，引入，添加点击返回顶部事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;!-- 返回顶部 --\u0026gt; \u0026lt;aside class=\u0026#34;back-top\u0026#34; @click=\u0026#34;backTop\u0026#34; v-if=\u0026#34;showBackTop\u0026#34;\u0026gt; \u0026lt;svg class=\u0026#34;back_top_svg\u0026#34;\u0026gt; \u0026lt;use xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; xlink:href=\u0026#34;#backtop\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { backTop() { animate(document.body, {scrollTop: \u0026#39;0\u0026#39;}, 400, \u0026#39;ease-out\u0026#39;) } } } \u0026lt;/script\u0026gt; 加载动画 创建单独的 Loading 子组件\n制作动画 一跳一跳的 load 动画\n1 2 3 4 5 @keyframes load { 0% { transform: translateY(0); } 50% { transform: translateY(-50px); } 100% { transform: translateY(0px); } } 下方椭圆阴影变化动画（水果跳上去阴影变小，水果落下来阴影变大）\n1 2 3 4 5 @keyframes ellipse { 0% { transform: scale(1); } 50% { transform: scale(0.3); } 100% { transform: scale(1); } } animation 语法\n1 animation: name duration timing-function delay iteration-count direction fill-mode play-state; name 是设定的关键帧的名字；duration 是多久完成这个动画；timing-function 是动画运动的方式，比方说 linear 就是线性运动，ease-in-out 是动画缓慢过渡，加速再减速；iteration-count 设置为 infinite 迭代次数无穷大，即为不断重复。\n设定背景图片为加载动画图，并配上动画：\n1 2 3 4 5 6 7 8 .load-img { background: url(../../../images/icon_loading.png) no-repeat 0 0; animation: load .6s ease-in-out infinite; } .load-ellipse { animation: ellipse .6s ease-in-out infinite; } 图片定时切换 load 图片一列七个，每次弹跳变换不同的图片，绑定一个变换的 style 属性，通过调整 background 的位置改变图片\n1 \u0026lt;div class=\u0026#34;load-img\u0026#34; :style=\u0026#34;{ backgroundPositionY: -(positionY%7) + \u0026#39;rem\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 再开一个定时器，每 0.6s 换一次图片。一定记得销毁组件之前销毁定时器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 export default { data() { return { positionY: 0, timer: null } }, mounted() { this.timer = setInterval(() =\u0026gt; { this.positionY++; }, 600) }, beforeDestroy() { clearInterval(this.timer) } } background 参考 animation 参考 使用 引入 Loading 子组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;!-- 加载动画 --\u0026gt; \u0026lt;transition v-if=\u0026#34;showLoading\u0026#34;\u0026gt; \u0026lt;Loading/\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Loading from \u0026#39;../fun/Loading.vue\u0026#39; export default { data() { return { showLoading: true, // 显示加载动画，默认显示，页面加载后隐藏 } }, components: { Loading }, mounted { shopList(this.latitude, this.longitude, this.offset, this.restaurantCategoryId).then(res =\u0026gt; { this.hideLoading() }) }, methods: { hideLoading() { this.showLoading = false } } } \u0026lt;/script\u0026gt; 星星打分 新建一个组件，先做一排五个灰色星星\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;star-container\u0026#34;\u0026gt; \u0026lt;svg class=\u0026#34;star\u0026#34; v-for=\u0026#34;item in 5\u0026#34; :key=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;use xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; xlink:href=\u0026#34;#star\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style lang=\u0026#39;scss\u0026#39; scoped\u0026gt; @import \u0026#39;../../../style/mixin.scss\u0026#39;; .container { position: relative; width: 3rem; } .star-container { display: flex; position: absolute; height: 0.6rem; top: 0.2rem; } .star { height: 0.6rem; width: 0.6rem; fill: #d1d1d1; } \u0026lt;/style\u0026gt; 再做一排橙色星星，宽度按照父组件传过来的 rating 计算比例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;div :style=\u0026#34;{ width: (rating/5)*3 + \u0026#39;rem\u0026#39; }\u0026#34; class=\u0026#34;star-overflow\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;star-container\u0026#34;\u0026gt; \u0026lt;svg class=\u0026#34;star orange\u0026#34; v-for=\u0026#34;item in 5\u0026#34; :key=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;use xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; xlink:href=\u0026#34;#star\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;rating\u0026#39;] } \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#39;scss\u0026#39; scoped\u0026gt; .star-overflow { overflow: hidden; height: 100%; position: relative; .orange { fill: $orange; } } \u0026lt;/style\u0026gt; 在父组件中引入，使用，传入 rating：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;RatingStar :rating=\u0026#39;item.rating\u0026#39;\u0026gt;\u0026lt;/RatingStar\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import RatingStar from \u0026#39;../fun/RatingStar.vue\u0026#39; export default { components: { RatingStar } } \u0026lt;/script\u0026gt; 目标功能 定位功能 选择城市 搜索地址 展示所选地址附近商家列表 ","permalink":"https://oooldgreen.github.io/posts/frontend/vue2-elm-day3/","summary":"第三天啦，加油！\n数据处理 需要处理数据将数组分成 8 个一组，方便后面引入 Swiper 的分页器效果\n1 2 3 4 5 msiteFood(geohash).then(res =\u0026gt; { while (res.length !== 0) { this.foodCate.push(res.splice(0, 8)) } }) 处理前返回的结果: 处理后的数组: 使用 Swiper 在 Vue 中使用Swiper Swiper 文档 先安装 Swiper\n1 npm install swiper --save-dev 根据文档在组件中引入 Swiper 的 js 和 css，引入 Swiper 只有基础模块，如果需要其他组件功能需要另外引用，最后在 mounted 中初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // msite.vue // 引入 js import Swiper, { Pagination } from \u0026#39;swiper\u0026#39; // 引入 css import \u0026#39;swiper/css\u0026#39; import \u0026#39;swiper/css/pagination\u0026#39; export default { components: { Swiper, SwiperSlide }, mounted() { // 引入 Swiper const swiper = new Swiper(\u0026#39;.","title":"Vue2 Elm 项目记录 Day3"},{"content":"路由 参考\n路由跳转 标签跳转 使用 \u0026lt;router-link\u0026gt; 进行导航，通过传递 to 来指定链接，\u0026lt;router-view\u0026gt; 作为路由出口，是路由匹配的组件渲染的地方。\n1 2 3 4 5 \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Go to Home\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/city\u0026#34;\u0026gt;\u0026lt;router-link\u0026gt; \u0026lt;!-- 需要传参的情况 --\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/city/\u0026#39; + this.id\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; 事件跳转（编程式路由导航） 使用 this.$router.push('') 或 router.push('')\n1 2 // 固定页面 this.$router.push(\u0026#39;/home\u0026#39;); 带参数的情况 第一种方法：解构赋值\n1 2 3 4 this.$router.push(`/city/${id}`) router.push(`/users/${username}`) router.push({ path: `/user/${username}` }) 第二种方法：query 传参，相当于 get 请求，router.push 用法相同\n1 2 3 4 5 6 this.$router.push({ path: \u0026#39;/city\u0026#39;, query: { id: this.id } }) 第三种方法：params 传参，相当于 post 请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 this.$router.push({ path: \u0026#39;/city\u0026#39;, params: { id: this.id } }) // router.push 中含有 path 就会忽略 params router.push({ name: \u0026#39;/city\u0026#39;, params: { id: this.id } }) 在跳转的组件中获取参数可以使用 this.$route.params 或 this.$route.query\n路由重定向 1 const routes = [{ path: \u0026#39;/home\u0026#39;, redirect: \u0026#39;/\u0026#39; }] 如果链接到一个命名路由，直接在 redirect 中指定路由名字\n1 const routes = [{ path: \u0026#39;home\u0026#39;, redirect: { name: homepage } }] 横跨历史 向前移动一条记录：router.go(1)\n向前移动三条记录：router.go(3)\n向后移动一条记录：router.go(-1)\nVuex State 状态 在 state 中记录 vuex 所有状态。Vuex 从根组件注入所有子组件，子组件可以通过 this.$store 访问。或者引入 mapState 使用 store.state 获取数据。\n1 2 3 4 5 6 7 8 import {mapState} from \u0026#39;vuex\u0026#39; export default { computed: { ...mapState([ \u0026#39;latitude\u0026#39;, \u0026#39;longtitude\u0026#39; ]) } } Mutation 提交 Mutation 更改 State 可以在组件中使用 this.$store.commit('xxx') 提交 mutation，也可以借助 mapMutation 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）\n1 2 3 4 5 6 7 8 9 import { mapMutation } from \u0026#39;vuex\u0026#39; export default { mutations: { increment(state, payload) { state.count += payload } } store.commit(\u0026#39;increment\u0026#39;, 10) } 使用常量替代 Mutation 事件类型 创建一个 mutation-types.js 文件，在其中定义常量\n1 2 3 4 // mutation-types.js export default { export const SOME_MUTATION = \u0026#39;SOME_MUTATION\u0026#39; } 在 index.js 中引入\n1 2 3 4 5 6 7 8 9 10 11 // index.js import { SOME_MUTSTION } from \u0026#39;./mutation.types.js\u0026#39; const store = { state: { ... }, mutations: { [SOME_MUTATION] (state) { // 修改 state } } } 将经纬度数据存储在 Vuex 中 1. 创建常量\n新建 mutations-type.js 文件，新建用于记录地址的常量。这样做是为了使所有的 mutation 更加直观，容易理解，当然也可以不这么做。\n1 2 3 4 5 6 // mutations-type.js // 记录具体地址 export const RECORD_ADDRESS = \u0026#39;RECORD_ADDRESS\u0026#39; // 记录经纬度 export const SAVE_GEOHASH = \u0026#39;SAVE_GEOHASH\u0026#39; 2. Vuex 定义存储操作\n先在 index.js 中定义 state\n1 2 3 4 5 6 // index.js const state = { latitude: \u0026#39;\u0026#39;, longitude: \u0026#39;\u0026#39;, geohash: \u0026#39;\u0026#39; } 再在 mutations.js 中定义存储数据操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // mutations.js import store from \u0026#39;.\u0026#39; import { SAVE_GEOHASH, RECORD_ADDRESS } from \u0026#39;./mutation-type\u0026#39; export default { // 记录经纬度 [SAVE_GEOHASH](state, geohash) { state.geohash = geohash }, // 记录地址 [RECORD_ADDRESS](state, { latitude, longitude }) { state.latitude = latitude state.longitude = longitude } } 3. 在组件中操作保存数据\n老规矩，先引入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { mapMutations } from \u0026#39;vuex\u0026#39; export default { data() { return { // 存储 City.vue 传递过来的地址 geohash = \u0026#39;latitude, longtitude\u0026#39; geohash: \u0026#39;\u0026#39;, } }, // methods 中引入 mutations 方法 methods: { ...mapMutations([\u0026#39;SAVE_GEOHASH\u0026#39;, \u0026#39;RECORD_ADDRESS\u0026#39;]) } } 在获取到所需的信息之后将其存储在 Vuex 中\n1 2 this.SAVE_GEOHASH(this.geohash) this.RECORD_ADDRESS(res) 搜索城市页面 跳转到城市页面 在 index.js 中引入路由\n1 2 3 4 5 const routes = [{ path: \u0026#39;/city/:cityId\u0026#39;, name: \u0026#39;city\u0026#39;, component: City }] 在 Home.vue 中根据城市 id 进行跳转\n1 2 3 4 5 6 \u0026lt;router-link :to=\u0026#34;\u0026#39;/city/\u0026#39; + this.cityId\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;guessCity\u0026#34;\u0026gt;{{guessCity}}\u0026lt;/span\u0026gt; \u0026lt;svg class=\u0026#34;arrow_right\u0026#34;\u0026gt; \u0026lt;use xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; xlink:href=\u0026#34;#arrow-right\u0026#34; style=\u0026#34;width:20px;height:20px;\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/router-link\u0026gt; 获取城市信息 根据 API 文档，需要传递 id，根据城市 id 获取城市信息\n1 2 // getData.js export const currentCity = cityId =\u0026gt; fetch(\u0026#39;/v1/cities/\u0026#39; + cityId) 在 City 组件 mounted 中，通过 this.$route.params.cityId 获取到从 Home 组件传过来的参数 id，用这个 id 发送请求，获取 res 为当前 id 城市信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // City.vue import { currentCity } from \u0026#39;../../service/getData\u0026#39; export default { data () { return { cityId: \u0026#39;\u0026#39;, cityName: \u0026#39;\u0026#39; } }, mounted() { this.cityId = this.$route.params.cityId currentCity(this.cityId).then(res =\u0026gt; { this.cityName = res.name }) } } 将城市名称渲染在页面的 header 上\n1 2 \u0026lt;!-- City.vue --\u0026gt; \u0026lt;h4 class=\u0026#34;city-title ellipse\u0026#34;\u0026gt;{{cityName}}\u0026lt;/h4\u0026gt; 搜索地址 获取用户输入的 keyword 添加 v-model 即可\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入学校、商务楼、地址\u0026#34; required v-model=\u0026#34;keyword\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { keyword: \u0026#39;\u0026#39; } } } \u0026lt;script\u0026gt; 根据 keyword 发送请求 在 getData.js 中\n1 2 3 4 5 // getData.js export const getPois = (cityId, keyword) =\u0026gt; fetch(\u0026#39;/v1/pois\u0026#39;, { city_id: cityId, keyword: keyword }) 在 City 组件中根据 keyword 发送请求，并将结果保存在 data 中，用 li 渲染在页面中，如果没有搜索结果显示提示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;section class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;searchUl\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in poisMsg\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;h4 class=\u0026#34;search-title\u0026#34;\u0026gt;{{item.name}}\u0026lt;/h4\u0026gt; \u0026lt;p class=\u0026#34;address ellipse\u0026#34;\u0026gt;{{item.address}}\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;footer class=\u0026#34;no-result\u0026#34; v-if=\u0026#34;noresult\u0026#34;\u0026gt;很抱歉！无搜索结果\u0026lt;/footer\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { currentCity, getPois } from \u0026#39;../../service/getData\u0026#39; export default { data () { return { // 搜索历史在提交关键词后隐藏 historyHide: false, // 存储搜索出的结果 poisMsg: [], // 无搜索结果 noresult: false } }, methods: { searchPois() { // 隐藏搜索历史 this.historyHide = true getPois(this.cityId, this.keyword).then(res =\u0026gt; { if(res.length === 0) { // 如果结果为空，没有搜索结果时显示提示 this.noresult = true } else { this.noresult = false this.poisMsg = res } }) } } } \u0026lt;/script\u0026gt; 搜索历史 搜索历史可以存储在 localStorage 中。进入页面时从 localStorage 中获取历史搜索记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 export default { data() { history: [] }, methods: { // 得到历史搜索记录 initData() { if(getStore(\u0026#39;history\u0026#39;)) { this.history = JSON.parse(getStore(\u0026#39;history\u0026#39;)) } else { this.history = [] } } }, mouted() { // 初始化搜索记录 this.initData() } } 跳转到下一个页面之前将用户点击的地址记录在 localStorage 中\n1 2 \u0026lt;!-- 给搜索结果绑定点击事件 --\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in poisMsg\u0026#34; :key=\u0026#34;index\u0026#34; @click=\u0026#34;nextPage(item)\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 export default { data() { return { // 记录历史 history: [] } }, method: { nextPage (place) { // 如果存在历史记录，搜索是否存在该记录 if (this.history) { let checkRepeat = false this.history.forEach((item) =\u0026gt; { if (place.geohash === item.geohash) { checkRepeat = true } }) if (!checkRepeat) { this.history.push(place) } } else { this.history.push(place) } // 存储到 localStorage setStore(\u0026#39;history\u0026#39;, this.history) } } } 一些小优化 封装 localStorage 的存储等方法 添加一个优化 js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // mUtils.js // 获取 localStorage export const getStore = name =\u0026gt; { if (!name) return; return window.localStorage.getItem(name) } // 存储 localStorage export const setStore = (name, content) =\u0026gt; { if (!name) return; window.localStorage.setItem(name, content) } // 移除 localStorage export const removeStore = name =\u0026gt; { if (!name) return; window.localStorage.removeItem(name) } 在需要的时候直接引入\n1 2 3 import { getStore, setState } from \u0026#39;../../config/mUtils\u0026#39; this.history = getStore(\u0026#39;history\u0026#39;) setStore(\u0026#39;history\u0026#39;, this.history) 隐藏历史记录 当用户提交文本框内容，隐藏历史记录显示搜索记录；当输入框失去焦点时，如果用户没有输入则重新显示历史记录。可以给 input 框添加 @blur 事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;search\u0026#34; placeholder=\u0026#34;请输入学校、商务楼、地址\u0026#34; required v-model=\u0026#34;keyword\u0026#34; @blur=\u0026#34;hideHistory\u0026#34; \u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; methods: { hideHistory () { if (this.keyword.trim()) { this.historyHide = true } else { this.historyHide = false // 清空搜索结果 this.poisMsg = [] } } } \u0026lt;/script\u0026gt; 清空历史记录 1 2 \u0026lt;!-- City.vue --\u0026gt; \u0026lt;footer class=\u0026#34;history-clear\u0026#34; v-if=\u0026#34;this.history.length!==0\u0026#34; @click=\u0026#34;clearHistory\u0026#34;\u0026gt;清空所有\u0026lt;/footer\u0026gt; 1 2 3 4 5 6 clearHistory () { // 移除 localStorage 存储 removeStore(\u0026#39;history\u0026#39;) // 初始化数据 this.initData() } 1 2 3 4 5 // mUtil.js export const removeStore = name =\u0026gt; { if (!name) return; window.localStorage.removeItem(name) } 目标功能 定位功能 选择城市 搜索地址 ","permalink":"https://oooldgreen.github.io/posts/frontend/vue2-elm-day2/","summary":"路由 参考\n路由跳转 标签跳转 使用 \u0026lt;router-link\u0026gt; 进行导航，通过传递 to 来指定链接，\u0026lt;router-view\u0026gt; 作为路由出口，是路由匹配的组件渲染的地方。\n1 2 3 4 5 \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Go to Home\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/city\u0026#34;\u0026gt;\u0026lt;router-link\u0026gt; \u0026lt;!-- 需要传参的情况 --\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/city/\u0026#39; + this.id\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; 事件跳转（编程式路由导航） 使用 this.$router.push('') 或 router.push('')\n1 2 // 固定页面 this.$router.push(\u0026#39;/home\u0026#39;); 带参数的情况 第一种方法：解构赋值\n1 2 3 4 this.$router.push(`/city/${id}`) router.push(`/users/${username}`) router.push({ path: `/user/${username}` }) 第二种方法：query 传参，相当于 get 请求，router.push 用法相同\n1 2 3 4 5 6 this.$router.push({ path: \u0026#39;/city\u0026#39;, query: { id: this.id } }) 第三种方法：params 传参，相当于 post 请求","title":"Vue2 Elm 项目记录 Day2"},{"content":"《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》 课程 是 2020 年秋科大自动化系本科课程录制版。在介绍计算机网络体系架构的基础上，自上而下、以互联网为例系统地阐述了网络体系结构各层次的主要服务、工作原理、常用技术和协议，包括应用层、传输层、网络层、数据链路层和物理层，最后是网络安全原理和协议。\n计算机网络和互联网 Internet：是一堆的网络，通过一系列网络交换节点互联互通，向用户提供服务。互联网是分布式的应用进程和提供通信服务的基础设施（应用层以下都是）。\nInternet 标准：\nRFC IETF 互联网组成：\n节点 节点及主机上的应用程序 路由器（网络层）、交换机（链路层）等网络交换设备 边 access 接入网链路 backbone 主干链路 协议：根据协议发出请求和接受请求，按照规范解析报文。协议规范了语法、语义、时序、动作四个方面。 互联网的三个子系统：\n边缘 (edge) ：存在网络应用和支撑其运行的协议栈 核心 (core) ：进行数据交换，是由路由和交换机构成的分布式系统 接入 (access)：把边缘接入到网络核心，通过网络核心将数据发送给目标主机，可以有有线或无线通信链路 网络边缘 (edge) 应用进程之间的通信模式 客户端/服务器模式 (CS 模式) 资源在服务器，以服务器为主，服务器支撑，由客户端向服务器请求资源 典型的主从模式 缺点：服务器压力大，服务器通信消耗大，服务器宕机影响大，性能随业务量增加断崖式下降 对等 (peer-peer, P2P) 模式 很少（甚至没有）专门的服务器，每个节点既是客户端，又是服务器 面向连接的服务 目标是在端系统之间传输数据。需要在数据传输之前做好准备（握手），例如 TCP 协议。\nTCP 服务的特性：\n面相连接 可靠的（不重复、不失序、不出错、不丢失） 流量控制（协调发送方发送速度和接收方接收速度） 拥塞控制（考虑网络路径的通行能力） 应用场景：可靠性要求高的应用 UDP（用户数据报）服务的特性：\n无连接的服务，不需要握手 不可靠 无流量控制，无拥塞控制 快速 将端口细分到进程到进程 应用场景：实时流媒体，远程会议，域名解析等 网络核心 (core) 关键功能有路由和转发\n1. 电路交换\n端到端的资源被分配给从源端到目标端的呼叫 \u0026ldquo;call\u0026rdquo;，为每个呼叫预留一条专有通道进行数据交换。\n每条链路被分为若干不同的 pieces，每个呼叫分配独享的链路，资源专用，不共享，这样连接一建立起来就能保证性能，但是会有资源浪费的缺陷，通常被传统电话网络采用，不太适合计算机之间的通信。\n将带宽分成片的方法：频分 (FDM)、时分 (TDM)、波分 (WDM)\n不适合计算机之间通信的原因：\n连接建立时间长 计算机之间通信有突发性，浪费的片较多（独享链接没有被使用的时候也无法被别的呼叫使用） 可靠性不高 2. 分组交换\n以分组 (package) 为单位，在每一个单位节点经历存储再转发，使用带宽的全部，资源共享，按需使用。\n统计多路复用：分组没有固定的模式\n数据存储-转发的方式：\n数据报网络：无连接，每个分组传送是独立的，标识完整的目标主机地址，直接传输。 虚电路网络 (virtual circuit)：有连接，先握手，在交换节点之间先建立虚拟的电路，确保网络层的连接，然后每个分组携带虚电路号进行存储转发。虚电路靠信令建立起来。 有连接和面向连接：\n有连接体现在每一跳的节点上都是有连接的。 面向连接只体现在发送和接收端连接 优点：\n支持的用户更多 共享性 适合突发式的数据传输 缺点：\n时延是在每个交换节点中存储的时间之和 和 不太确定的排队时延 如果路由器缓存用完了，分组将会被抛弃（丢包） 过度使用会造成网络拥塞 接入网 (access) modem：调制解调器 DSL/IDSL：仍然用调制解调的方式，用 4kHz 以上的带宽，分上行和下行链路 线缆网络：有线电缆双向改造，在不同频段传输不同信道的数据，上下行 家庭网络 企业接入网络：直接接到以太网路交换机上 无线接入网络：\nWlan 广域无线接入 (wide-area，蜂窝网络、3G、4G、5G等) 无线局域网 WIFI 物理媒体：\n导引型媒体：有形的 例如同轴电缆（两根同心的铜导线）、光纤（单/多模）、光缆、双绞线 低误码率，双向，高速，安全 非导引型媒体：传输电磁波，携带要传输的数据 例如地面微波、LAN、wide-area、卫星等 无需物理“线缆”，双向，有反射、吸收、干扰 互联网结构\n端系统通过接入 ISPs (Internet Service Providers) 连接到互联网，ISP 也要互相连接，但每两个 ISP 互相连接不具有扩展性，可以将每个接入 ISP 都连接到全局 ISP (Global ISP)，客户 ISPs 和提供者 ISPs 有经纪合约 ISP 之间合作可以完成业务的扩展，对等互联 (peer linking) 的结算关系 多个 ISP 接入入互联网交换点 IXP (Internet exchange point) 内容提供者 ICP (Internet Content Providers) 费用高，范围有限，需要部署 DC (data center)，通常部署在离 ISP 较近的地方，用专用线缆连在一起 互联网层次结构是松散的：\n中心：第一层 ISP，国家覆盖，效率极高 第二层 ISP：更小些的（通常是区域性的）ISP 第三层：Local ISP ICP等 ISP 之间的连接：\nPOP：高层 ISP 向低层接入，涉及费用结算 多宿 (multi home)：低层 ISP 向多个高层 ISP 接入 IXP：对等连接，通常不涉及费用结算 ICP自己部署的专用网络，同时和各级 ISP 连接 延时、丢失和吞吐量分析 分组延时\n节点处理延时 排队延时\n根据当时网络情况\n流量强度 = L*a/R\n流量强度趋近于 0，排队延时很小；流量强度趋近于 1，延时变得很大，趋近于无穷大；设计系统时流量强度不能大于 1。 传输延时：L/R 传播延时：d/s 分组丢失：链路的队列缓冲区容量有限，分组到达一个满的队列就会被丢失，丢失的分组可能会被前一个节点或源端系统重传也可能根本不重传\n吞吐量：在源端和目标端之间传输的速率（数据量/单位时间）\n瓶颈链路：端到端路径上，限制端到端吞吐的链路\n协议层次 把网络复杂的功能分成功能明确的层次，每一层实现一个或一组功能，功能中有其上层能够使用的功能 —— 服务。本层借助层间的接口访问下层提供的服务，通过协议交换信息。\n服务 (Service)：低层实体向上层实现提供他们之间通信的能力\n原语 (primitive)：上层使用下层服务的形式\n服务访问点 (SAP, Services Access Point)：使用下层提供的服务通过层间的接口地点\n服务和协议的差别和关系：\n服务：垂直，低层向上层提供的，通过原语操作 协议：对等层互相通信的过程中遵循的集合 联系：本层协议的实现靠下层提供的服务来实现，本层实体通过协议为上层提供更高级的服务 数据单元 (DU, data unit) SDU 处理：\n一对一的关系：上层发送了一个数据单元，没有超出分组大小，直接加上 header 成为 n-PDU (protocol data unit) 一对多的关系：上层发送的一个数据单元太大了，需要拆解成分组大小 多对一的关系：上层发送很多个非常小的数据单元，下层将数据单元组合成一个分组 分层系统的优缺点：\n对付复杂的系统 概念化：结构清晰，便于交流和讨论 结构化：模块化易于维护和系统升级 子系统相互交换信息降低了效率 Internet 协议栈 应用层：应用报文 (message) 之间的交互，提供网络应用服务 传输层：报文段 (message segment)，TCP 段，UDP 数据报，进程到进程的区分，网络层提供的有可能不可靠的服务变成可靠的服务 网络层：源主机到目标主机，以分组（packet, 或无连接的方式: 数据报 datagram）为单位的端到端的数据传输，重要任务转发、路由 链路层：在相邻两点间传输以帧 (frame) 为单位的数据，交换机 物理层：在线路上传输位 (bit) ISO/OSI 参考模型 应用层 表示层：允许应用解释传输的数据，加密、压缩、机器相关的表示转换 会话层：建立会话管理，数据交换的同步，检查点，恢复 传输层 网络层 链路层 物理层 应用层 原理 进程通信 进程：在主机上运行的应用程序\n客户端进程：发起通信的进程 服务器进程：等待连接的进程 区分不同的进程：寻址-标识\n用IP地址和端口号标识 任何应用进程之间都可以用两个端节点来表示（end point） Socket 采用 Socket 减少层间传输的信息量，并且便于管理，实际上是一个整数。就像 OS 打开文件返回的句柄一样，对句柄操作就是对文件的操作。\nTCP Socket：\n两个进程通信持续一段时间，通信关系稳定，本质是用一个整数表示两个应用实体之间的通信关系，是一个具有本地意义的标示，包括 ——\n四元组：源IP、源端口、目标 IP、目标端口\n传输报文的时候交两样东西：socket 和数据本身\nUDP Socket：\n由于不需要建立连接，内容只有二元组：本 IP、本端口，仅代表一个端节点\n传输报文的时候交三样东西：socket、数据本身 和 对方的 IP 和 port\n应用层协议 运行在不同端系统上的应用进程如何进行交换报文\n公开协议：由 RFC 文档定义，允许互操作，如 HTTP、SMTP\n私有协议：不公开，如 Skype\nTCP 和 UDP 都不提供安全性\n怎么增加安全性？\n安全 TCP：\nSSL 加密，提供加密的 TCP 连接 私密性 数据完整性 端到端的鉴别 Web 和 HTTP Web 页由一些对象组成，，对象可以是 HTML 文件， JPEG 图像，Java 小程序等，通过 URL 对每个对象进行引用。\nURL格式：\n协议 - 用户：口令 - 主机名 - 路径名 - 端口\n1 Prot://user:psw@www.someSchool.edu/someDept/pic.gif:port HTTP HTTP 即超文本传输协议，是 Web 的应用层协议，使用客户/服务器模式，客户端负责请求、接收和显示 Web 对象（各种浏览器），服务端负责对请求进行相应并发送浏览器（服务器）。\nHTTP 是无状态的，使用 TCP ，客户发起 TCP 连接默认端口号为 80，在浏览器交换 HTTP 报文之后连接关闭。\n无状态：服务器不需要维护客户端的状态，无记忆\n往返时间 (RTT, round-trip time)：一个小的分组从客户端到服务器再回到服务端的时间（字节数很少可以忽略传输时间）\n响应时间：包括一个 RTT 发起 TCP 连接，一个 RTT 请求 HTTP 并等待 HTTP 响应 ，文件传输时间（这样一个大的对象传输时间无法忽略）= 2 * RTT + 传输时间\nHTTP 请求格式：\n请求报文格式：请求行、首部行、换行回车符，表示报文结束 1 2 3 4 5 6 GET /somedir/page,html HTTP/1.1 Host: www.someschool.edu User-agent: Mozilla/4.0 Connection: close Accept-language: fr （一个额外的换行回车符） 响应报文：状态行（协议版本/状态码/响应状态信息）、首部行、数据（如请求的 HTML 文件） 状态码：\n200 Ok 301 Move Permanently 400 Bad Request 404 Not Found 505 Http Version not Supported HTTP 1.0 请求方式：\nGET POST HEAD：要求服务器在响应报文中不包含请求对象 -\u0026gt; 故障跟踪 HTTP 1.1 请求方式；\nGET/POST/HEAD PUT：实体主体中的文件上载到 URL 字段规定的路径 DELETE：删除 URL 字段规定的文件 默认连接方式：流水方式的持久 HTTP 连接，客户端向客户端连接请求，建立连接之后默认不关闭连接。客户端遇到一个引用对象就立即产生一个请求，所有引用对象指花费一个 RTT 是有可能的。\nCookie 可以使连接有状态的小甜饼～\n在 HTTP 响应报文中有一个 cookie 的首部行 请求报文中含有一个 cookie 的首部行 用户端系统中保留一个 cookie 文件 在 web 站点有一个后端数据库 能做什么呢？举例：\n用户验证 购物车 个性化推荐 缺点是隐私性问题，cookie 不够安全，会暴露你的访问行为，被攻击后信息也会暴露\nWeb 缓存：不访问服务器就满足用户的需求，可以降低服务器的负载，降低客户端请求响应时间，通常由 ISP 安装\nFTP 文件传输协议，端口号为 21，客户端通过控制连接（带外传送）完成用户认证，之后可以发出一系列指令传输文件（上载或下载等）\nFTP 命令、响应\nUSER username PASS password LIST RETER filename 311 Username OK, password required Email 电子邮件 3个主要组成部分：\n用户代理：客户端软件，Outlook，Gmail 等 邮件服务器：管理和维护发送给用户的邮件，输出报文队列保持待发送邮件报文 简单邮件传输协议：SMTP，使用 TCP 在客户端和服务器之间传送 email 报文，端口号 25，使用持久报文，要求报文为 ASCII 编码 邮件访问协议：\nPOP (Post Office Protocol)：邮局访问协议 IMAP (Internet Mail Access Protocol)：邮件访问协议，更多特性，在服务器上处理存储的报文 HTTP：web 访问，文件上载下载，收发邮件 DNS 域名 DNS (Domain Name System), 应用于其他应用的应用。IP 地址标识主机、路由器，不容易记忆，所以用有意义的字符串来标识地址，由 DNS 负责转换成为二进制的网络地址。DNS 运行在 53 号端口，在边缘系统中实现，主要思路是分层的命名（防止重名）、分布式的数据库。\nDNS 目的：\n主要目的：完成主机 - IP 地址的转换 其他目的有 主机别名到规范名的转换 邮件服务器别名到邮件服务器正规名转换 负载均衡 DNS 域名结构：\n层次树状结构 Internet 根被划为几百个顶级域 按国家分: .jp; .cn 按通用的 (genetic): .com; .gov; .edu; .int; .mil; .net; .org; .web \u0026hellip; 每个域下面还可以划分若干个子域 树叶是主机 名字服务器：\n区域 (zone)：域名，将 DNS 名字空间划分为互不相交的区域，每个区域都是树的一部分 每个区域都有一个名字服务器 允许被放置在区域之外保障可靠性 权威 DNS 服务器：组织机构的 DNS 服务器，提供组织机构服务器可访问的主机和 IP 之间的映射，组织机构可以选择实现自己维护或者某个服务提供商维护 TLD 服务器（顶级域服务器）： 负责顶级域名和所有国家顶级域名\n资源记录 (RR) 区域名字服务器维护的资源记录，RR 格式：(name, value, type, ttl)\n内容包括：\nDomain_name 域名 TTL (time to live)：生存时间（权威记录/缓冲记录），权威记录 TTL 可以无限大，永久存在 Class 类别：如果是 Internet，是 IN Value 值 Type 类别 Type:\nA - name 为主机 CNAME - name 为规范名字的别名 NS - name 域名 MX - name为对应 mail 服务器名字 P2P 模式应用 Peer to Peer，每个节点既是客户端也是服务端，是一类应用\n优点：分布式流量，可靠性较高\n用例：\n文件的分发 流媒体点播 VoIP (Skype) 实时音频视频 overlay：客户端配置文件中给出一个列表，记录若干个经常运行的节点的 IP，向这些节点按照协议发出连接报文，在响应中随机选取节点建立起 overlay\n非结构化 P2P：覆盖网络 (overlay) 中节点间的关系是随意的\n集中化目录 完全分布式：限制范围的泛洪 (flooding) 查询，例如 TTL，进行标记 混合体：例如 BitTorrent 结构化 (DHT, Distributed Hash Table) P2P：节点间可以构成有序的 overlay（树、环等）\nCDN (Content Distribution/Delivery Networks) 多媒体流化服务：DASH (Dynamic, Adaptive Streaming over HTTP)\n智能客户端：客户端自适应决定 —— 什么时候请求块，请求什么编码速率的视频块，哪里请求块\nCDN: 部署缓存节点，存储服务内容，就近为用户提供服务\nSocket 编程 socket：分布式应用进程之间的门，传输层协议提供的端到端服务接口\nTCP 套接字编程\n服务器端 服务器先运行，创建欢迎 socket 和本地端口捆绑 bind 建立 connetionSocket，连接 welcomeSocket，阻塞式等待用户连接 客户端 4. 客户端创建 clientSocket，隐式绑定（操作系统自动分配）\n5. 主动和服务端建立连接，connect(ClientSocket, sad)，记录服务器 IP 和端口 连接通信\n6. 服务器端接受连接，返回一个有效值，解除阻塞，建立连接\n7. 客户端发送请求 send request\n8. 服务器调用 read 接收，write 回复\n9. 客户端从服务器读取 read reply UDP Socket 编程\n没有握手，服务器和客户端没有连接 传送的数据可能乱序也可能丢失 建立 serverSocket bind readfrom，等待客户端发送数据 客户端创建 clientSocket 客户端隐式 bind 客户端 sendto 发送数据 服务端 readfrom 解除阻塞，sendto 返回数据 客户端 read reply from 读取服务端返回的数据 关闭 socket 传输层 ","permalink":"https://oooldgreen.github.io/posts/cs/computer-networks/","summary":"《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》 课程 是 2020 年秋科大自动化系本科课程录制版。在介绍计算机网络体系架构的基础上，自上而下、以互联网为例系统地阐述了网络体系结构各层次的主要服务、工作原理、常用技术和协议，包括应用层、传输层、网络层、数据链路层和物理层，最后是网络安全原理和协议。\n计算机网络和互联网 Internet：是一堆的网络，通过一系列网络交换节点互联互通，向用户提供服务。互联网是分布式的应用进程和提供通信服务的基础设施（应用层以下都是）。\nInternet 标准：\nRFC IETF 互联网组成：\n节点 节点及主机上的应用程序 路由器（网络层）、交换机（链路层）等网络交换设备 边 access 接入网链路 backbone 主干链路 协议：根据协议发出请求和接受请求，按照规范解析报文。协议规范了语法、语义、时序、动作四个方面。 互联网的三个子系统：\n边缘 (edge) ：存在网络应用和支撑其运行的协议栈 核心 (core) ：进行数据交换，是由路由和交换机构成的分布式系统 接入 (access)：把边缘接入到网络核心，通过网络核心将数据发送给目标主机，可以有有线或无线通信链路 网络边缘 (edge) 应用进程之间的通信模式 客户端/服务器模式 (CS 模式) 资源在服务器，以服务器为主，服务器支撑，由客户端向服务器请求资源 典型的主从模式 缺点：服务器压力大，服务器通信消耗大，服务器宕机影响大，性能随业务量增加断崖式下降 对等 (peer-peer, P2P) 模式 很少（甚至没有）专门的服务器，每个节点既是客户端，又是服务器 面向连接的服务 目标是在端系统之间传输数据。需要在数据传输之前做好准备（握手），例如 TCP 协议。\nTCP 服务的特性：\n面相连接 可靠的（不重复、不失序、不出错、不丢失） 流量控制（协调发送方发送速度和接收方接收速度） 拥塞控制（考虑网络路径的通行能力） 应用场景：可靠性要求高的应用 UDP（用户数据报）服务的特性：\n无连接的服务，不需要握手 不可靠 无流量控制，无拥塞控制 快速 将端口细分到进程到进程 应用场景：实时流媒体，远程会议，域名解析等 网络核心 (core) 关键功能有路由和转发\n1. 电路交换","title":"计算机网络"},{"content":"月光之下，我们哭过笑过；月光之下，你曾说你爱我\n重复的听着这首歌 自己难过 自己泪流 茉莉花随着风飘落 回家的路 一个人走过 也许是哪里走错 路的尽头没有人等我 岁月总是擦肩而过 流星划过 不能陪你到苍老 陪你到老 什么也不留\n天亮以后 留住你该用什么理由 别难过 所有的痛苦 都由我默默承受 我以为我做得到 这是一段文字。空荡的梦，怎么写我们的从今以后。天亮以后，就再也牵不到你的手；天亮以后，我会慢慢离开你的梦。天亮以后，留住你该用什么理由；天亮以后，留住的只剩下寂寞。别难过，所有的痛苦都由我默默承受。\n这是一段引用。月光之下，我们哭过笑过；月光之下，你曾说你爱我，风雨再大，我会一直握着你的手。\n呵护着你，不让你走。重复的听着这首歌，自己难过，一个人泪流。\n1 2 3 4 5 // 这是一段代码 function test(a) { console.log(\u0026#39;hello World!\u0026#39;, a) } test(10) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 这是一段代码 function test(a) { console.log(\u0026#39;hello World!\u0026#39;, a) } test(10)// 这是一段代码 function test(a) { console.log(\u0026#39;hello World!\u0026#39;, a) } test(10)// 这是一段代码 function test(a) { console.log(\u0026#39;hello World!afunction test(a) function test(a) function test(a) function\u0026#39;) } test(10)// 这是一段代码 function test(a) { console.log(\u0026#39;hello World!\u0026#39;, a) } test(10)// 这是一段代码 function test(a) { console.log(\u0026#39;hello World!\u0026#39;, a) } test(10)// 这是一段代码 function test(a) { console.log(\u0026#39;hello World!\u0026#39;, a) } test(10)// 这是一段代码 function test(a) { console.log(\u0026#39;hello World!\u0026#39;, a) } test(10)// 这是一段代码 function test(a) { console.log(\u0026#39;hello World!\u0026#39;, a) } test(10) 这是一行公式： $$ \\sum_{\\substack{i=1}}^{n}a_{n} = a\\frac{1-q^{n}}{1-q} $$\n这是行内公式：\\( a^2 + b^2 = c^2 \\)\n","permalink":"https://oooldgreen.github.io/posts/daily/test/","summary":"\u003cp\u003e月光之下，我们哭过笑过；月光之下，你曾说你爱我\u003c/p\u003e","title":"Test 测试用例"},{"content":"我羡慕鹰，因为它拥有自由。我羡慕云，因为它可以走到哪就是哪，不问来处，不问去处。\n今年的立冬不知怎么的并不寒冷，我最爱的秋天在这个我觉得一切都很糟糕的一年里，居然出奇的长了。所以这一年也就不算太糟糕。\n夜晚的月亮很高很亮很圆，我走它就跟着我走，多少个夜晚我走出大楼抬头看着它，它也望着我，我就这样一摇一摆的走回家。我知道月亮会一直陪着我，即使有一天我没有看见它，但它就在那里。\n这一年的混乱里还有很多希望。我想人活下去要么是非活下去不可的责任，要么就是怀抱希望。我的人生仿佛在这一年才真正开始，以往的浑浑噩噩都过去了，我的道在混沌中浮现出来，我的心指引我去向何方。我不知道我能不能达成心愿，但我想至少要试一试。现在还不到放弃的时候。\n瑜伽和冥想时老师常常说，接纳一切的情绪，好的坏的，痛苦的，承认它，接纳它，拥抱它，明白它是正常的情绪，然后带着它继续自己该做的事。所以我试着拥抱我的痛苦、彷徨和紧张、焦虑，带着它继续我的工作安排，一旦开始工作，焦虑就结束了，有时候缺少的也许就是这一份行动。我常常质疑自己，想要放弃，但是一转念又不甘心，我明明还有很多想要做的事情，所以就只有默默的继续做下去，不问去处了，反正也不知道在哪。\n想起高中时候许的愿望，不过是“行到水穷处，坐看云起时”。\n","permalink":"https://oooldgreen.github.io/posts/draft/emotion-221109/","summary":"\u003cp\u003e我羡慕鹰，因为它拥有自由。我羡慕云，因为它可以走到哪就是哪，不问来处，不问去处。\u003c/p\u003e","title":"立冬有感"},{"content":"汇总 Promise 对象的由来、用法、方法和 async/await。\n从是什么，怎么用开始讲起，然后讲讲具体有哪些方法和应用场景，最后再浅提一下 async/await。\n为什么要有 Promise 对象 一句话：解决回调地狱 (callback hell)\n如果你想进行一个异步操作，比方说，有先后顺序的打印两个结果，你会怎么写？\n也许你可以使用回调函数（callback），因为回调函数必须依赖另一个函数执行，我们可以借此确保打印的先后顺序。定时器就是一个常见的回调函数。\n1 2 3 4 // 1s后输出callback setTimeout(function () { console.log(\u0026#39;callback\u0026#39;) }, 1000); 当要嵌套很多回调函数时，每个嵌套都用一层括号包裹，最后的结果就是嵌套了很多层括号，代码变得非常复杂，令人迷惑\u0026hellip;\u0026hellip; 摘抄JavaScript高级程序设计（第4版）上的一段代码体会一下，这段代码表现的是异步返回值依赖了另一个异步返回值时的情况——\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function double(value, success, failure) { setTimeout(() =\u0026gt; { try { if (typeof value !== \u0026#39;number\u0026#39;) { throw \u0026#39;Must provide number as first argument\u0026#39;; } success(2 * value); } catch (e) { failure(e); } }, 1000); } const successCallback = (x) =\u0026gt; { double(x, (y) =\u0026gt; console.log(`Success: ${y}`)); }; const failureCallback = (e) =\u0026gt; console.log(`Failure: ${e}`); double(3, successCallback, failureCallback); // Success: 12（大约 1000 毫秒之后） 这个时候如果可以推出一种方法，可以方便又直观的表示出异步操作的先后顺序，又不用一层一层的写回调函数就好了\u0026hellip;\u0026hellip;\n这个方法就是 ES6 推出的 Promise\nPromise对象是什么 Promise是一个异步操作，通俗来说就是Promise里面的程序运行完根据返回值再进行下一步操作，这样不用一直在函数体里一直嵌套回调。\n一共有三种状态：PENDING（待定）、FULFILLED/RESOLVED（成功）、REJECTED（失败）。这是一个“承诺”，从一开始的PENDING开始，状态一旦改变便不会再变，成败只在一线之间（bushi。所以最后结果就是返回RESOLVED或者REJECTED，一般来说返回RESOLVED进行下一步，返回则REJECTED抛出错误。\nPromise对象怎么用 用new实例化，接住resolve或reject\n1 2 3 4 5 6 7 const p1 = new Promise((resolve, reject) =\u0026gt; { if (/* 操作成功 */){ resolve(value); } else { reject(error); } }) Promise 实例方法 Promise.prototype.then() then 是 Promise 的实例方法，在它的实例对象上，作用是作为 Promise 状态改变后的回调函数使用。\nthen 接收最多两个参数，一个是 resolved 后的操作，一个是 rejected 后的操作。这两个参数都是可选的，如果提供的话就会分别在进入两个状态后返回一个新的 Promise，因此可以使用链式调用，也就是在 then 方法后再调用 then方法，写很多个 then 方法也没问题。\n采用链式调用就会按先后顺序执行，因此可以规定一组回调函数按照次序进行调用，也就是第一个回调执行完之后，返回新的 Promise 作为下一个回调的参数传入第二个回调函数，以此类推。\n1 2 3 4 5 6 7 const p1 = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;Success!\u0026#39;); }); p1.then((value) =\u0026gt; { console.log(value); // \u0026#34;Success!\u0026#34; }); Promise.prototype.catch() 用于指定发生错误时的回调\n1 2 3 4 5 const p1 = new Promise((resolve, reject) =\u0026gt; { throw new Error(\u0026#39;error!\u0026#39;); }).catch(e =\u0026gt; { console.log(e); }); Promise 静态方法 Promise.all() 用于一组 Promise 实例，当所有实例状态都为 fulfilled 才会返回成功，否则会抛出状态为 rejected 的实例返回的错误\n1 const p = Promise.all([p1, p2, p3, ...]) Promise.any() 用于一组 Promise 实例，当其中一个实例状态转变为 fulfilled，该实例状态就变为 fulfilled；当所有实例的状态都为 reject，实例才会变为 reject 状态。\n1 const p = Promise.any([p1, p2, p3, ...]) Promise.race() 用于一组 Promise 实例，实例的状态根据第一个改变状态的 Promise 改变\n1 const p = Promise.race([p1, p2, p3, ...]) Promise.resolve() 将现有对象转变为 Promise 实例对象。\n如果参数是一个 Promise，返回执行后新的 Promise 对象；\n如果参数是一个带有 then 方法的对象，则将这个对象转为 Promise 后立即执行 then 方法；\n如果参数根本就不是对象，则返回一个新的 Promise 对象，状态为 resolved；\n如果参数不带任何参数，则直接返回一个状态为 resolved 的 Promise 对象。\nPromise.reject() 用于返回失败后的实例对象，状态为 rejected ，并给定后续的处理方法。\n手写实现 Promise 实现 Promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 定义三种状态 const PENDING = \u0026#39;pending\u0026#39;; const REJECTED = \u0026#39;rejected\u0026#39;; const RESOLVED = \u0026#39;resolved\u0026#39;; class MyPromise { constructor(executor) { this.status = PENDING; // 存储成功和失败的结果 this.value = undefined; // 成功和失败的回调函数 this.resolvedCallbacks = []; this.rejectedCallbackes = []; const resolve = (value) =\u0026gt; { if (this.status === PENDING) { this.status = RESOLVED; this.value = value; this.resolvedCallbacks.forEach(cb =\u0026gt; cb(value)) } } const reject = (value)=\u0026gt; { if(this.status = PENDING) { this.status = REJECTED; this.reason = value; this.rejectedCallbaecks.forEach(cb =\u0026gt; cb(value)) } } try { executor(resolve, reject); } catch(e) { reject(e) } } // 实现 then 函数 then(onFulfilled, onRejected) { return new MyPromise((resolve, reject) { if(this.status === RESOLVED) { onFulfilled(this.value); } if(this.status === REJECTED) { onRejected(this.value); } if(this.status === PENDING) { this.resolvedCallbacks.push(onFullfilled); this.rejectedCallbacks.push(onRefected); } }); } } 实现 Promise.all() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyPromise { static all(promises) { let results = []; let resolvedCounter = 0; return new Promise((resolve, reject) =\u0026gt; { promises.forEach((promise, index) =\u0026gt; { promise.then(value =\u0026gt; { results[index] = value; resolvedCounter++; if(resolvedCounter === promises.length) { return resolve(results); } }).catch(e =\u0026gt; { reject(e); }); }); }); } } async/await 又是啥？ async/await 其实是 Generator 的语法糖，可以让我们以更简洁的方式写出异步行为，解决了“链式调用地狱”，可能是终极解决方法。\nasync 关键字用于声明异步函数，也就是说它是一种标识符，写在函数前面表明函数里面有需要异步执行的操作。\nawait 关键字用于暂停异步函数代码的执行，等待 await 右边的 Promise 被解决或被拒绝后再异步回复函数进程（即使 await 右边只是一个普通的值，也会被隐式地被包装成一个 Promise 并异步执行）。\n在错误处理机制中，async/await 可以使用 try/catch 代码块，用 catch 捕捉到错误。\n利用 async/await 实现 sleep()\n1 2 3 4 5 6 7 8 9 10 11 async function sleep(delay) { return await new Promise(resolve =\u0026gt; setTimeout(resolve, delay)); } // 使用 async function foo() { await sleep(1500); console.log(\u0026#39;Hello World :)\u0026#39;); } foo(); // 暂停 1500ms 后输出 \u0026#39;Hello World :)\u0026#39; 参考 JavaScript高级程序设计（第4版） 阮一峰老师的ES6入门 MDN ","permalink":"https://oooldgreen.github.io/posts/frontend/js-promise/","summary":"汇总 Promise 对象的由来、用法、方法和 async/await。\n从是什么，怎么用开始讲起，然后讲讲具体有哪些方法和应用场景，最后再浅提一下 async/await。\n为什么要有 Promise 对象 一句话：解决回调地狱 (callback hell)\n如果你想进行一个异步操作，比方说，有先后顺序的打印两个结果，你会怎么写？\n也许你可以使用回调函数（callback），因为回调函数必须依赖另一个函数执行，我们可以借此确保打印的先后顺序。定时器就是一个常见的回调函数。\n1 2 3 4 // 1s后输出callback setTimeout(function () { console.log(\u0026#39;callback\u0026#39;) }, 1000); 当要嵌套很多回调函数时，每个嵌套都用一层括号包裹，最后的结果就是嵌套了很多层括号，代码变得非常复杂，令人迷惑\u0026hellip;\u0026hellip; 摘抄JavaScript高级程序设计（第4版）上的一段代码体会一下，这段代码表现的是异步返回值依赖了另一个异步返回值时的情况——\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function double(value, success, failure) { setTimeout(() =\u0026gt; { try { if (typeof value !== \u0026#39;number\u0026#39;) { throw \u0026#39;Must provide number as first argument\u0026#39;; } success(2 * value); } catch (e) { failure(e); } }, 1000); } const successCallback = (x) =\u0026gt; { double(x, (y) =\u0026gt; console.","title":"Promise"},{"content":"记录一些 shell 指令\n基础指令 date： 日期\n1 2 missing % date 2022年11月 1日 星期二 19时45分27秒 CST echo: execute a command with arguments\n1 2 3 4 5 6 7 8 missing % echo hello\\ world hello world missing % echo $PATH /Library/Frameworks/Python.framework/Versions/3.10/bin missing % which echo echo: shell built-in command pwd: get the path\n1 2 missing % pwd /tmp/missing cd: to a specific directory, . refers to the current directory, .. refers to the parent directory\n1 2 3 4 5 6 7 missing /home % cd .. missing % pwd / missing % cd home missing /home % pwd /home ls: see what lives in current directory\n1 2 3 4 5 missing % ls Applications Postman Aurora\tPublic Desktop\tZotero ... -h / --help: get help -l: use a long listing format -l *.md: 得到特定格式的文件 1 2 missing % ls *.txt hello.txt\thello2.txt man: have the manual page\n操作文档 cp: copy a file 1 missing % cp markdown.md ../food.md rm: remove a file 1 missing % rm ../food.md mv: rename or move a file 1 missing % mv hello.md food.md mkdir: make a new directory rmdir: move a directory {}: expand a common substring in a series of commands. 相同字符可以缩写，例如 touch foo{,1,2,10} 创建四个文档 - foo、foo1、foo2、foo10 1 2 # This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h touch {foo,bar}/{a..h} \u0026lt;(): execute and place the output in a temporary file and subsitute the \u0026lt;() with that file\u0026rsquo;s name 1 2 3 4 5 6 7 touch foo/x bar/y # Show differences between files in foo and bar diff \u0026lt;(ls foo) \u0026lt;(ls bar) # Outputs # \u0026lt; x # --- # \u0026gt; y 定义和输出变量 没有变量的时候单引号双引号都可以，有变量的话只有双引号起作用。\n1 2 3 4 5 6 7 ~ % foo=bar ~ % echo $foo bar ~ % echo \u0026#39;Value is $foo\u0026#39; Value is $foo ~ % echo \u0026#34;Value is $foo\u0026#34; Value is bar Write things in a file 1 2 3 # 运行文件 ~ % source mcd.sh ~ % mcd test !! - Entire last command 复制上一行指令 $0 - Name of the script $1 to $9 - Arguments to the script. $1 is the first argument and so on $@ - All the arguments $# - Number of arguments $$ - Process identification number (PID) for the current script $_ - Last argument from the last command $? - Return code of the previous command 1 2 3 4 5 6 ~ % true ~ % echo $? 0 ~ % false ~ % echo $? 1 1 2 3 ~ % foo=$(pwd) ~ % echo $foo /Users/missing 连接项目 \u0026lt; file: input from this file \u0026gt; file: output to this file \u0026gt;\u0026gt;: append file 1 2 3 4 5 6 7 8 9 10 11 12 missing % echo hello \u0026gt; hello.txt missing % cat hello.txt hello missing % cat \u0026lt; hello.txt \u0026gt; hello2.txt missing % cat hello2.txt hello missing % cat \u0026lt; hello.txt \u0026gt;\u0026gt; hello2.txt missing % cat hello2.txt hello hello |: pipeline, the output text of each process (stdout) is passed directly as input (stdin) to the next one 1 2 missing % ./semester.txt | grep -i last-modified last-modified: Fri, 28 Oct 2022 00:33:31 GMT cat: concatenate and print files Others chmod: change file modes or Access Control Lists 1 2 3 4 5 6 7 missing % ls -l total 8 -rw-r--r-- wheel 61 11 1 20:13 semester.txt missing % chmod +rwx semester.txt missing % ls -l total 8 -rwxr-xr-x wheel 61 11 1 20:13 semester.txt touch: change file access and modification times 1 missing % touch semester.txt curl: transfer a URL Finding tools Finding files . 表示在当前文件夹下搜索，-name 后面为想要查找的文档名称\n1 2 3 4 5 # Find all directories named src ~ % find . -name src -type d ~ % find . -name \u0026#39;*.md\u0026#39; ./archetypes/default.md ./content/draft/promise.md locate 用于在一个 database 里面查找文档，效率更高。updatedb 用于更新 database。\nFinding commands Ctrl + R 检索你的历史指令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ~ % history 1043 man ffmpeg 1044 tldr convert 1045 tldr ffmpeg 1046 find . -name src -type d 1047 ls 1048 cd public 1049 ls 1050 cd .. 1051 cd snowcabin 1052 find . -name src -type d 1053 find . -name src -type md 1054 find . -name \u0026#39;*.tmp\u0026#39; 1055 find . -name \u0026#39;*.md\u0026#39; 1056 locate shell 1057 locate missing-semester 1058 update db # only print commands that contains the substring \u0026#39;locate\u0026#39; ~ % history 1 | grep locate 1056 locate shell 1057 locate missing-semester ","permalink":"https://oooldgreen.github.io/posts/cs/shell/","summary":"\u003cp\u003e记录一些 shell 指令\u003c/p\u003e","title":"Shell操作指南"},{"content":"方便反复诵读复习\n1. 计算机原理 1.1 输入 URL 到渲染完成的整个过程 根据域名递归查找地址，先查找缓存，没有则进行 DNS 解析，向域名服务器获取 IP ，返回给浏览器 建立 TCP 连接 客户端发送请求，服务端收到请求并响应 客户端接收到响应结果，得到资源文档，可能进行解压缩 解析文档构建 DOM 树和 CSSOM 树，合成 Render 树 进行布局，再渲染，呈现页面 面试题之从敲入 URL 到浏览器渲染完成\n1.2 TCP 三次握手和四次挥手 详解TCP 三次握手和四次挥手\nTCP 三次握手 客户端发送 SYN 报文，初始化 ISN 序列，SYN 标识为置为一，发送后进入 SYN_SENT 状态 服务端接收后发送 SYN + ACK 报文，并把客户端发送报文的 ISN 序列号 +1 作为自己的 ACK 字段，把 ACK 和 SYN 标志位都置为 1，进入 SYN_REVD 状态 客户端接收后发送 ACK 报文，ACK 标志位置为 1，这次可以携带应用层数据，进入 ESTABLISHED 状态 为什么是三次握手？ 确保序列号有效的同步 确定客户端和服务端收发正常 避免资源浪费 TCP 四次挥手 客户端发送 FIN 报文，进入 FIN_WAIT_1 状态 服务端收到后，发送 ACK 报文，进入 CLOSED_WAIT 状态 客户端收到报文后，进入 FIN_WAIT_2 状态 服务端处理完数据后，发送 FIN 报文，服务端进入 LAST_ACK 状态 客户端收到后，发送 ACK 报文，进入 TIME_WAIT 状态，等待 2MSL 时间后自动关闭，进入 CLOSED 状态 服务端收到 ACK 报文后，直接进入 CLOSED 状态 为什么是四次挥手？ 确保客户端和服务端都不再接收和发送数据 服务端可能有数据要处理，所以 ACK 和 FIN 分开发送 等待 2MSL 时间是为了确保服务端收到报文信息，如果没有收到，服务端会重新发送 FIN 报文，客户端就要再次发送 ACK 报文，因此至少是一个报文来回的时间 1.3 TCP 和 UDP 的区别 TCP 面向连接传输，需要先建立连接，UDP 不需要 TCP 基于可靠性传输，UDP 保证传输速度不保证传输质量 TCP 一对一传输，UDP 可以一对一、一对多、多对多 TCP 有拥塞控制和流量控制，UDP 没有 UDP 头部长度固定，开销小 1.4 HTTP 和 HTTPS HTTP 和 HTTPS 的区别 HTTPS 加入了 SSL 证书进行加密，HTTP 不用 HTTPS 更安全，更利于 SEO HTTPS 基于传输层，HTTP 基于应用层 HTTPS 标准端口 43，HTTP 标准端口 80 状态码 参考\n1: 临时响应，需要继续处理消息\n102 Processing: 处理中，通常需要很长时间才能完成请求时发送\n2: 请求成功\n3: 重定向\n301 Moved Permanently: 资源（网页等）永久被移动至其他 URL，之后任何新的请求都使用新的 URL 替代\n302 Found: 临时移动，客户端应使用原有 URL\n304 Not Modified: 所请求的资源未修改过\n4: 请求失败，客户端错误\n400 Bad Request: 客户端请求语法错误，服务器无法理解\n404 Not Found: 无法找到资源\n5: 请求失败，服务端错误\n500 Internal Server Error: 通用错误信息，服务器遇到了未曾预料到的情况，无法完成请求\n502 Bad Gateway: 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应\n1.5 用户登录认证 Cookie 和 Session 在服务端创建 Session，将 SessionId 发送给客户端保存在 Cookie 中，在以后发送请求时自动携带，服务端分解 Cookie 后验证成功将请求返回客户端。\n缺点：\n数据都保存在服务器端，服务器有压力。 用 Cookie 不用 Session，所有数据都保存在客户端的话一旦 Cookie 被劫持，所有数据全部泄露 Token 无状态令牌，用户信息被加密到 Token 中，服务端解密就能得知是哪个用户，一般保存在浏览器本地缓存中。服务器端生成 Token 后返回给客户端，客户端再次发送请求时在 headers 中添加 Token，服务端校验成功就会返回数据。\n生成方式：JWT (Json Web Token)，三部分组成 header + payload + signature\n优点：\n防止 CSRF 攻击，token 可以存放在前端任何地方，不用保存在 cookie 中，浏览器也不会自动把 token 放入 headers 里，不能通过 document.cookie 直接拿到，攻击者无法访问用户的 token 服务器端不需要存放 token，减轻服务端压力 1.6 浏览器缓存 浏览器缓存将文件保存在客户端，可以减少对带宽的占用，减少响应时间，提升用户体验。\n页面的缓存状态是由 http-header 字段决定的，相关的字段为 Cache-Control、Expires、Last-Modified/If-Modified-Since、Etag/If-None-Match。\n大致分为协商缓存和强缓存。\n强缓存 Cache-Control：\n设置 max-age，设定时间内可以直接从本地缓存中读取文件并加载 public/private，设置缓存能否在用户间共享 no-cache， 不进行缓存 Expires： 设置页面过期的时间，过期时间内可以直接读取缓存\n协商缓存 协商缓存有两组字段：Last-Modified/If-Modified-Since 和 Etag/If-None-Match，其中 Etag 优先级更高。\n请求过程是检查是否命中协商缓存，如果资源无更新，返回 304 并直接读取资源，如果修改过，返回 200 并加载新资源。\nLast-Modified/If-Modified-Since：分别表示最后修改的时间和缓存对象最后修改时间，相互对比得出资源是否被更新 Etag/If-None-Match：hash 生成特殊标识，如果更新资源 hash 值就会改变，再缓存文件存储的字符串进行对比 1.7 浏览器本地存储方式 cookie、localStorage 和 sessionStorage cookie、localStorage 和 sessionStorage 都是浏览器本地缓存方式。\n区别：\ncookie 在服务器和客户端之间来回传递，localStorage 和 sessionStorage 都是浏览器本地保存 cookie 存储空间很小，大概只有 4kb ，sessionStorage 和 localStorage 存储空间较大，大概在 5M 左右 sessionStorage 在浏览器窗口关闭时就会自动清空，localStorage 需要手动清除，cookie 在设置的有效期之内一直有效 localStorage 和 cookie 在所有同源窗口中共享，sessionStorage 换个页面就不行了 1.8 安全攻击 CSRF 跨站请求伪造。伪造 cookie ，通过模仿用户行为进行操作。\n防御方式：\n使用验证码 添加 referer 字段 使用 token 验证 XSS 跨站脚本攻击。通过注入恶意代码，读取用户敏感信息，在用户浏览页面时进行攻击。\n防御方式：\n开启 set-cookie: httponly，禁止 js 脚本访问 cookie 输入输出检查，对用户输入的字符进行转义 1.9 前端优化 SEO方法 meta标签的优化：标题、网站描述、关键词、目录、编码语种等 关键词：密度、相关度、突出性考虑 了解主要搜索引擎的检索排序方式 链接交换，其他网站链接到你的网站越多，你的网站访问量就越大 合理使用标签，使搜索网站更容易抓取内容 性能优化 内容 减少请求 减少 DNS 查找 加载顺序 CSS 在前，JS 在后 减少 404 服务器优化 使用 CDN 缓存 延迟加载、预加载组件 GZip 压缩 路由懒加载、图片懒加载 使用雪碧图 图片懒加载 参考\n内联图片：将图片的 src 放在自定义的属性里面，利用 js 检查标签是否在视窗中，如果在将自定义的属性赋值给 src 属性就可以了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 获取所有图片 const imgList = document.querySelectorAll(\u0026#39;img\u0026#39;) // 用于记录当前显示到了哪一张图片 let index = 0; function lazyload() { // 获取浏览器视口高度,这里写在函数内部是考虑浏览器窗口大小改变的情况 const viewPortHeight = window.innerHeight for (let i = index; i \u0026lt; imgList.length; i++) { // 这里用可视区域高度减去图片顶部距离可视区域顶部的高度 const distance = viewPortHeight - imgList[i].getBoundingClientRect().top; // 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明图片已经出现在了视口范围内 if (distance \u0026gt;= 0) { // 给图片赋值真实的src，展示图片 imgList[i].src = imgList[i].getAttribute(\u0026#39;data-src\u0026#39;); // 前i张图片已经加载完毕，下次从第i+1张开始检查是否需要显示 index = i + 1; } } } // 再加一个节流函数 // 使用的时候挂载： window.onload = lazyload() intersection observer：要考虑兼容性 css图像：利用 background-image，当 js 检测到元素处于视窗中，加一个 class 类名引用外部图片资源 更全面的 js 功能实现\n路由懒加载 动态导入代替静态导入\n1 2 3 4 // 将 import UserDetails from \u0026#39;./views/UserDetails\u0026#39; // 替换成 const UserDetails = () =\u0026gt; import(\u0026#39;./views/UserDetails\u0026#39;) 使用 webpack（babel）分块导入，只需要使用命名 chunk，魔法注释提供 chunk name\n1 2 const Users = () =\u0026gt; import(/* webpackChunkName: \u0026#34;users-rights-roles\u0026#34; */ \u0026#39;../components/user/Users.vue\u0026#39;) const Rights = () =\u0026gt; import(/* webpackChunkName: \u0026#34;users-rights-roles\u0026#34; */ \u0026#39;../components/power/Rights.vue\u0026#39;) 服务端渲染 SSR 服务器端生成HTML直接返回给浏览器。\n实现方式：\nVue + Nuxt.js 优势：\n减少网络传输，提高传输效率 首屏渲染快 有利于 SEO，提高搜索效率 缺点：\n不利于前后端分离，开发效率不高 占用服务器的资源 1.10 axios axios 是一个基于 promise 的 HTTP 库，支持 promise 的所有 API 它可以拦截请求和响应 它可以转换请求数据和响应数据，并对响应回来的内容自动转换为 json 类型的数据 它安全性更高，客户端支持防御 XSRF axios 拦截器 拦截器分为请求拦截器和响应拦截器\n请求拦截器用于在请求之前做处理，例如带上 token、时间戳等，响应拦截器用于接口返回之后做处理，例如判断 token 是否过期。\n原理：创建一个 chn 数组，数组中保存了拦截器相应方法和 dispatchRequest，请求拦截器放到 dispatchRequest 前面，响应拦截器放到 dispatchRequest 后面，把请求拦截器和响应拦截器 forEach 放到数组中，用 promise 出队列的方式保证他们的执行顺序挨个执行。\n1.11 跨域方法 同源策略：协议、域名、端口号都相同，保护浏览器免受攻击\nJSONP：利用 script 标签可以进行跨域请求的特性，创建一个 script 标签写入跨域请求，并通过 callback 接收响应。仅支持 get 方法 CORS：后端处理，前端写入字段 Access-Control-Allow-Origin Vue Proxy 1 2 3 4 5 6 7 8 // vue.config.js/webpack.config.js // 优点：配置简单 // 缺点：不能灵活控制请求是否走代理，因为都会走代理 module.exports={ devServer:{ proxy:\u0026#39;http://xxx.xxx.xxx:5000\u0026#39; } } WebSocket：提供全双工、双向通信 PostMessage：HTML5 中的 API 1.12 前后端实时通信 轮询：客户端隔一段时间询问一次，适用于小型应用，实用性不高 长轮询：客户端询问后，服务端有新消息才返回 WebSocket：长连接，适用于微信、网络互动游戏等 iframe 流：插入一个隐藏的 iframe，利用其 src 属性在服务器和客户端之间创建一条长连接，服务器向 iframe 传输数据（通常是 HTML，内有负责插入信息的 javascript），来实时更新页面。兼容性好，但长连接会增加开销 SSE：单向通道，服务器向浏览器推送资源 1.13 主流浏览器 浏览器 内核 IE Trident Firefox Gecko Chrome Blink Safari Webkit Opera Blink 1.14 get 和 post 请求的区别 get 回退是无害的，post 会再次提交请求 get 参数通过 url 进行传递，更不安全，有长度限制；post 参数放在 request body 中，更安全，没有长度限制 get 会被浏览器主动缓存保存参数，post 不会 get 产生一个 TCP 数据包，post 产生两个（在 Firefox 中只有一个） 2. JS 2.1 数据类型 数据类型 Number, Object，String, Boolean, Null, Undefined, BigInt, Symbol\nBigInt 和 Symbol 是 ES6 新的数据类型，Symbol 创建一个不重复的变量，可以用于 object 的 key。\n引用数据类型：Object，存储在堆中，栈中一个指针指向它 普通数据类型：除了 Object 以外其他的数据类型，存储在栈中 null 和 undefined 的区别 参考\nnull：表示被定义了，但是是空值，占用内存，通过 typeof 判断是 object (这是因为 typeof 通过二进制前三位判断数据类型，null 和 object 一样前三位都是 000) undefined：是一个变量未赋值 或 一个函数没有返回值 或 访问一个对象不存在 或 一个函数定义了形参但没有传递实参，通过 typeof 判断是 undefined 2.2 方法 判断数据类型的方法 typeof：只能区分基本数据类型，引用数据类型除了 function 会返回 function，其余都是 object constructor：用于引用数据类型，检测方法是获取实例的构造函数判断和某个类是否相同，如果相同就说明该数据是符合那个数据类型的，这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰。 instanceof：用于引用数据类型，检测数据类型是否在当前变量的原型链上 Object.prototype.toString.call()：适用于所有数据类型 toString 这个方法是用于返回当前调用者的对象类型的，返回[object [class]] call 是为了让 Object.prototype.toString 方法指向括号内指定的数据, 否则调用者是 Objec.prototype，返回永远都是[object Object] 数组方法 增删改查：push、pop、shift、unshift、concat、join、reverse、sort、map、forEach、reduce、slice、splice、forEach、filter、indexOf\n改变原数组：push、pop、shift、unshift、reverse、sort、splice\n不改变原数组：concat、join、filter、slice、reduce、map\n数组去重 Array from(new Set(array)) [...new Set(array)] filter 采用对象数组方法去重 1 2 3 4 5 6 7 8 9 10 11 function sort(arr){ let obj = {}; let newArr = []; for(let i = 0; i \u0026lt; arr.length; i++){ if(!obj[arr[i]]){ obj[arr[i]] = 1; newArr.push(arr[i]); } } return newArr; } 翻转字符串 split -\u0026gt; reverse -\u0026gt; join\n1 2 3 4 5 function reverse(str){ for(let i = 0; i \u0026lt; str.length; i++){ return str.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } map 和 forEach map 不改变原数组，开辟新空间，返回新数组，处理速度快 forEach 返回 undefined，改变原数组 for\u0026hellip;of 和 for\u0026hellip;in for in 通用的对象遍历，遍历对象的 key，也包括原型链上的属性的遍历，是以任意顺序迭代对象的可枚举属性 for of 遍历的是值，遍历可迭代属性，不能直接用来遍历对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Object.prototype.objCustom = function() {}; Array.prototype.arrCustom = function() {}; let iterable = [3, 5, 7]; iterable.foo = \u0026#39;hello\u0026#39;; for (let i in iterable) { console.log(i); // 0, 1, 2, \u0026#34;foo\u0026#34;, \u0026#34;arrCustom\u0026#34;, \u0026#34;objCustom\u0026#34; } for (let i in iterable) { if (iterable.hasOwnProperty(i)) { console.log(i); // 0, 1, 2, \u0026#34;foo\u0026#34; } } for (let i of iterable) { console.log(i); // logs 3, 5, 7 } \u0026hellip;扩展符 用于取出对象中可遍历的属性，浅拷贝到当前对象中\n2.3 异步方法 回调函数 Promise Generator：一个状态机，yield 暂停，next 下一步 Async/Await：基于 Promise 实现，看起来很像同步代码，使用上清晰明了 Promise 三种状态：PENDING、FULFILLED、REJECTED，状态一旦改变就不会再改变了\n方法:\nPromise.resolve(value) Promise.reject(reason) Promise.then：属于微任务 Promise.all：全部 Promise 成功，返回成功 Promise.any：一个 Promise 成功，返回成功 Promise.race：返回处理最快的那个的返回值，无论成功还是失败 实现 Promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 三个常量用于表示状态 const PENDING = \u0026#39;pending\u0026#39; const RESOLVED = \u0026#39;resolved\u0026#39; const REJECTED = \u0026#39;rejected\u0026#39; function MyPromise(fn) { const that = this this.state = PENDING // value 变量用于保存 resolve 或者 reject 中传入的值 this.value = null // 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用 that.resolvedCallbacks = [] that.rejectedCallbacks = [] function resolve(value) { // 首先两个函数都得判断当前状态是否为等待中 if(that.state === PENDING) { that.state = RESOLVED that.value = value // 遍历回调数组并执行 that.resolvedCallbacks.map(cb=\u0026gt;cb(that.value)) } } function reject(value) { if(that.state === PENDING) { that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb=\u0026gt;cb(that.value)) } } // 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了 try { fn(resolve,reject) }catch(e){ reject(e) } } 实现 Promise.then 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 最后我们来实现较为复杂的 then 函数 MyPromise.prototype.then = function(onFulfilled,onRejected){ const that = this // 判断两个参数是否为函数类型，因为这两个参数是可选参数 onFulfilled = typeof onFulfilled === \u0026#39;function\u0026#39; ? onFulfilled : v =\u0026gt; v; onRejected = typeof onRejected === \u0026#39;function\u0026#39; ? onRejected : e =\u0026gt; throw e; // 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数 if(this.state === PENDING) { this.resolvedCallbacks.push(onFulfilled) this.rejectedCallbacks.push(onRejected) } if(this.state === RESOLVED) { onFulfilled(that.value) } if(this.state === REJECTED) { onRejected(that.value) } } 实现 Promise.all 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 实现Promise.all()对象 function promiseAll(promises) { return new Promise(function(resolve, reject) { if (!isArray(promises)) { return reject(new TypeError(\u0026#39;arguments must be an array\u0026#39;)); } var resolvedCounter = 0; var promiseNum = promises.length; var resolvedValues = new Array(promiseNum); for (var i = 0; i \u0026lt; promiseNum; i++) { (function(i) { Promise.resolve(promises[i]).then(function(value) { resolvedCounter++ resolvedValues[i] = value if (resolvedCounter == promiseNum) { return resolve(resolvedValues) } }, function(reason) { return reject(reason) }) })(i) } }) } 2.4 原型及原型链 每个构造函数都有一个原型对象 prototype，原型有一个属性 constructor 指回构造函数，实例有一个内部指针 __proto__ 指向原型 prototype。每个构造函数都有一个属性 prototype 指向原型对象，原型对象又有指针指向上一级原型对象，构成一条原型链，原型链的顶端是 null\n实例、构造函数和原型的关系 2.5 ES6 新特性 let 和 const 箭头函数 模块化导入导出 import/export 异步 promise 解构赋值 类 新的语法糖结构\n1 2 3 4 5 6 7 class Person { constructor() { console.log(\u0026#39;Person\u0026#39;) } } let p = new Person; // Person 箭头函数 没有 this，继承上下文的 this 不能 new，没有 arguments let、const 和 var 的区别 var 有变量提升，let、const 没有变量提升 var 是函数作用域，let 和 const 是块级作用域 var 能声明多次，let 和 const 只能声明一次 const 变量声明必须赋值，一旦赋值不可更改 2.6 New 创造一个空对象 添加属性 __proto__ 指向构造函数的原型对象 创建 this 上下文 返回这个函数 2.7 闭包 在子函数内部调用了父函数的变量，并在函数外被引用就形成闭包。\n闭包中的变量在函数运行完毕后也不会被销毁，因此如果不及时回收可能造成内存泄露。\n最常用的应用是封装私有变量，通过闭包只将方法暴露在外，保证了变量的私有性。\n2.8 事件循环 从宏任务 script 开始，按照 宏任务 -\u0026gt; 微任务 的顺序循环处理。先从上到下执行，遇到宏任务放入宏任务队列，遇到微任务放到微任务队列，执行完进入微任务队列出队列处理，然后再处理宏任务，交替进行。\n宏任务 (macrotask)：script、定时器（setTimeout、setTimeInterval）、I/O 微任务 (microtask)：promise 的回调、nextTick、mutationObserver 2.9 事件委托 利用事件冒泡，把事件绑定到父元素上，当子元素发生事件时，通过冒泡触发父元素身上的事件从而做出响应。\n可以避免给每个子元素绑定事件，代码冗余且要加入子元素还要再次绑定事件。\n2.10 深拷贝和浅拷贝 浅拷贝只拷贝栈中的内容，深拷贝拷贝堆和栈中的内容。\n深拷贝的方法：\n第三方库，例如 lodash 中的 cloneDeep() 方法 JSON.parse(JSON.stringify(obj))，对于有些数据类型拷贝之后可能会丢失数据 新的方法 structuredClone()，但是对于 error 和 DOM 对象无法拷贝 自己写，递归拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function deepClone(obj) { // 检测是否为 Array let objClone = Array.isArray(obj) ? [] : {}; if (obj \u0026amp;\u0026amp; typeof obj === \u0026#34;object\u0026#34;) { for (key in obj) { if (obj.hasOwnProperty(key)) { //判断obj子元素是否为对象，如果是，递归复制 if (obj[key] \u0026amp;\u0026amp; typeof obj[key] === \u0026#34;object\u0026#34;) { objClone[key] = deepClone(obj[key]); } else { //如果不是，简单复制 objClone[key] = obj[key]; } } } } return objClone; } 2.11 bind, apply 和 call 作用都是改变 this 指向 apply 接收参数只能是一个数组，call 和 bind 接收参数要一个一个传入参数 bind 直接改变 this 指向并返回一个新函数，之后再调用 this 都指向 bind 绑定的第一个参数 实现 apply 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Function.prototype.myApply = function(context, args) { // 默认上下文为 window，不传参数就是空数组 context = context || windows; args = args ? args : []; // 给 context 新增一个独一无二的属性 // 用隐式绑定的方法调用函数 // 再删除添加的属性 const key = Symbol(); context[key] = this; const result = context[key](...args); delete context[key]; return result; } 实现 bind 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Function.prototype.myBind = function(context, ...args) { args = args ? args : []; const fn = this; const result = function(..fnArgs) { // 如果是通过 new 调用的，绑定 this 为实例对象 if (this instanceof result) { fn.apply(this, [...args, ...fnArgs]); } else { // 否则普通函数形式绑定 context fn.apply(context, [...args, ...fnArgs]); } } // 绑定原型链 result.prototype = Object.create(fn.prototype); return result; } 2.12 垃圾回收 引用计数 对一个对象被引用的次数计数，引用计数为 0 则清除\n可以即刻回收，计算过于复杂，效率低\n标记清除 对所有活动的对象进行标记，清除阶段没有标记的会被清除\n计算简单，但内存空间不连续，造成内存碎片\n2.13 防抖节流 防抖 只认最后一次，n 秒之内又被触发则重新计时，例如按钮提交\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // fn 是我们需要包装的事件回调, delay 是每次推迟执行的等待时间 function debounce(fn, delay) { // 定时器 let timer = null // 将 debounce 处理结果当作函数返回 return function () { // 保留调用时的 this 上下文 let context = this // 保留调用时传入的参数 let args = arguments // 每次事件被触发时，都去清除之前的旧定时器 if(timer) { clearTimeout(timer) } // 设立新定时器 timer = setTimeout(function () { fn.apply(context, args) }, delay) } } // 用 debounce 来包装 scroll 的回调 const better_scroll = debounce(() =\u0026gt; console.log(\u0026#39;触发了滚动事件\u0026#39;), 1000) document.addEventListener(\u0026#39;scroll\u0026#39;, better_scroll) 节流 只认第一次，在一定时间内只能触发一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // fn 是我们需要包装的事件回调, delay 是时间间隔的阈值 function throttle(fn, delay) { // last 为上一次触发回调的时间 let last = 0 // 将 throttle 处理结果当作函数返回 return function () { // 保留调用时的 this 上下文 let context = this // 保留调用时传入的参数 let args = arguments // 记录本次触发回调的时间（获取时间戳） let now = +new Date() // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值 if (now - last \u0026gt;= delay) { // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调 last = now; fn.apply(context, args); } } } // 用 throttle 来包装 scroll 的回调 const better_scroll = throttle(() =\u0026gt; console.log(\u0026#39;触发了滚动事件\u0026#39;), 1000) document.addEventListener(\u0026#39;scroll\u0026#39;, better_scroll) 2.14 函数柯里化 接收的多个参数转化为一个一个的参数的函数，指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。\n2.15 请求方式 fetch 请求 fetch 请求是基于 Promise 实现，最简单的 fetch 请求只需要带一个参数，就是请求的路径。fetch 请求会返回一个 Promise\n1 fetch(\u0026#39;urlxxx\u0026#39;).then(...) 用 await 写更清晰，必须用 try...catch 捕获错误\n1 2 3 4 5 6 7 8 9 async function getData() { try { const response = await fetch(\u0026#39;urlxxx\u0026#39;); // 得到 json 对象 return await response.json(); } catch(error) { thorw new Error(error); } } response.status 是 200 才会被认定为请求成功\n1 2 3 4 5 6 7 8 9 async function getData() { let response = await fetch(\u0026#39;xxx\u0026#39;); if(response.status === 200) { // 获取文本数据 return await response.text(); } else { throw new Error(response.statusText); } } 一些定制 HTTP 请求的参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const response = await fetch(url, { // 请求方法，可以是 POST，GET 等 methods: \u0026#34;POST\u0026#34;, // 请求数据的格式 headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, //\u0026#39;application/x-www-form-urlencoded\u0026#39; }, // 有新版本才使用服务器资源否则使用缓存，默认为 \u0026#34;default\u0026#34;，也就是先查找缓存 cache: \u0026#34;no-cache\u0026#34;, // 默认允许跨域请求，不允许是 \u0026#34;no-cors\u0026#34;，只允许同源是 \u0026#34;same-origin\u0026#34; mode: \u0026#34;cors\u0026#34;, // 默认同源发送 cookie，还有参数 \u0026#34;include\u0026#34; 和 \u0026#34;omit\u0026#34;，分别为一律发送和一律不发送 credentials: \u0026#34;same-origin\u0026#34;, }) ajax 请求 ajax 请求在XMLHttpRequest的基础上实现。XMLHttpRequest请求可以在不刷新整个页面的情况下更新数据。\n使用 Ajax 一共三步：创建对象、发送请求、监听响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 创建 ajax 对象 var xhr = new XMLHttpRequest(); /** 配置请求，三个参数 method、url、async * method: 可以是 get 或 post * url：请求路径 * async：true 或 false，是否异步 **/ xhr.open(\u0026#34;get\u0026#34;, \u0026#34;xxx\u0026#34;, true) // 发送请求，post 请求可以在其中放入数据 xhr.send(); // 监听响应 xhr.onload = function() { console.log(xhr.responseText); } 2.16 继承 原型链继承\n组合继承\n寄生式继承\n寄生式组合继承\n2.17 设计模式 创建型 单例模式：保证类的实例只有一个 建造者模式 结构型 代理模式 装饰器模式 适配器模式 行为型 发布订阅模式 迭代器模式 3. HTML 和 CSS 3.1 HTML5新特性 增加的特性 canvas video 和 audio localStorage 和 sessionStorage 语义化更好的元素内容，如 article, footer, header, nav, svg, figure, menu 新的技术 webworker、 websocket 移除的元素 纯表现的元素，例如 big，basefont，s，u 对可用性产生负面影响，例如 frame，noframes 3.2 HTML 语义化 结构清晰，利于 SEO 便于维护 没有 css 也能看懂 便于对浏览器、搜索引擎解析 3.3 HTML 中 title 属性和 alt 属性的区别 title 是图片加载后的标题，鼠标放上去后会显示 alt 是图片没有加载出来时候显示的内容 3.4 重绘和重排 重绘 (repaint) 部分重新绘制，style 修改。重绘不一定发生重排。\n触发场景：\ncolor 修改 text-align 修改 a:hover 修改 重排/回流 (reflow) 重新排版布局，涉及 DOM 的排版布局问题，性能损耗更多。重排必定发生重绘。\n触发场景：\n盒子长宽的改变 动画，伪类等引起的元素表面改动 display: none scroll、resize 页面 background 的修改 appendChild 等 DOM 元素操作 读取元素的属性，如 offsetLeft、offsetTop、scrollTop/Left/\u0026hellip; 如何避免重绘重排 通过改变 class 批量改变 style，同时尽可能减少受影响的 DOM 使用 absolute 或 fixed 脱离文档流 GPU 加速，开启之后的元素会被独立出来，不再影响其他布局 避免用 table 进行布局 3.5 BFC 块级格式化上下文，是一块独立渲染的区域，内部元素的渲染不会影响外部的元素。BFC 布局会把盒子在垂直方向上一个一个排列，盒子之间的距离由 margin 决定，两个相邻盒子的 margin 会互相重叠。BFC 区域不会与 float box 重叠，计算高度时，浮动盒子也参与计算。\n触发 BFC\n根元素 html display 为 inline-block，table-cell, table-caption position 为 fixed 或 absolute float 不为 none oveflow 不为 visible 3.6 CSS3 新特性 border-radius，box-shadow 文本效果 text-shadow、font-family、font-weight、font-style 多背景 rgba 动画 @keyframes 线性渐变 新增伪类 3.7 盒子模型 标准盒模型：box-sizing: content-box，设置的宽高只表示内容的宽高，不包含 padding 和 border 怪异盒模型：box-sizing: border-box，设置的宽高就是整个盒子的大小，包含 padding 和 border 3.8 水平垂直居中 绝对定位 1 2 3 4 5 6 7 .item{ position: absolute; top: 50%; left: 50%; margin-top: -75px; /* 设置margin-left / margin-top 为自身高度的一半 */ margin-left: -75px; } transform 1 2 3 4 5 6 .item{ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); /* 使用 css3 的 transform 来实现 */ } flex 布局 1 2 3 4 5 .parent{ display: flex; justify-content: center; align-items: center; } grid 布局 1 2 3 4 5 .parent { display: grid; justify-content: center; align-items: center; } table-cell 布局 1 2 3 4 5 6 7 8 .parent { display: table-cell; text-align: center; vertical-align:center; } .item { display: inline-block; } 3.9 画一个三角形 盒子宽高都设为 0，只设置 border，三条边都设置 transparent，只留一条边有颜色\n1 2 3 4 5 6 7 #demo { width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; } 3.10 三栏布局 三栏布局的要求是两边宽度固定，中间的盒子自适应布局，高度随内容撑起。\n圣杯布局 三个盒子放在一个父元素节点中，设置父盒子 padding 为左右两栏的宽度且 overflow: hidden，三个盒子设置左浮动 float: left。中间盒子宽度设置 100%，两栏宽度设好，左栏 margin 设置 -100% 且右移一个自身宽度，右栏 margin 设置 -自身宽度，且左移一个自身宽度。\n好处是不用添加 DOM 节点，但是 middle 部分小于 left 部分时布局会破碎。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;style\u0026gt; .parent { padding: 0 200px; overflow: hidden; } .column { float: left; position: relative; height: 200px; } .middle { width: 100%; background-color: pink; } .left { width: 200px; background-color: #eee; margin-left: -100%; left: -200px; } .right { width: 200px; background-color: #eee; margin-left: -200px; left: 200px; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;middle column\u0026#34;\u0026gt;middle\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left column\u0026#34;\u0026gt;left\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right column\u0026#34;\u0026gt;right\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 双飞翼布局 中间盒子外面需要再包一层盒子，将外面这层盒子设置 margin 为左右两栏的宽度，三个盒子设置浮动，中间盒子宽度 100%，两边盒子宽度设置好之后，左边盒子设置 margin-left 为 100%，右边盒子设置 margin-left 为 -自身宽度，最后父盒子清除浮动。\n好处是稳定，代码简洁，缺点是多加了 DOM 节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;style\u0026gt; .container { overflow: hidden; } .content, .left, .right { float: left; height: 200px; } .content { width: 100%; } .center { margin: 0 200px; background-color: pink; height: 200px; } .left { width: 200px; margin-left: -100%; background-color: #eee; } .right { width: 200px; margin-left: -200px; background-color: #eee; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;center\u0026#34;\u0026gt;center\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;left\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;right\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 3.11 link 和 @import 的区别 link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS(是一种描述和同步网站内容的格式，是使用最广泛的 XML 应用), 定义 rel 连接属性等作用 而 @import 是 CSS 提供的，只能用于加载 CSS 页面被加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载 import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题 总之，link 要优于 @import。 3.12 雪碧图 将一个页面设计到的图片包含到一张图片里去，然后通过定位的方法选取合适的图片。\n这样做的好处是：\n可以一次请求完所有图片，不用发很多请求，加快了速度，提升了页面性能 减少图片的字节，放在一起比单独的图片字节数更小 更换风格方便，只需要更换这张雪碧图所有的图标风格都可以改变 缺点是：\n切图很麻烦，还可能造成背景断裂 开发和维护都比较麻烦，一个图标元素的位置移动可能导致所有图标位置都要移动 3.13 伪类和伪元素 根本不同在于是否创建了新的 DOM 元素\n伪类操作文档中已有的元素，如 :hover、:link、:focus 伪元素创建新的元素进行操作，如 ::first-line、:before、:after 3.14 flex布局 参考\n容器的属性\nflex: wrap 决定如何换行，nowrap | wrap | wrap-reverse flex: direction 决定主轴的方向，row | row-reverse | column | column-reverse justify-content 决定主轴上的对齐方式 align-items 决定交叉轴上的对齐方式 项目的属性\ngrow：存在剩余空间时的放大倍数 shrink：空间不足时的缩小比例 basis：分配多余空间之前，主轴占据的空间 flex: 1 包含了三个元素：grow, shrink, basis，默认值为 0 1 auto 1 2 3 .item { flex: none | [ \u0026lt;\u0026#39;flex-grow\u0026#39;\u0026gt; \u0026lt;\u0026#39;flex-shrink\u0026#39;\u0026gt;? || \u0026lt;\u0026#39;flex-basis\u0026#39;\u0026gt; ] } 3.15 rem 和 em rem 是根据根节点的字体大小比例调整 em 是根据父节点的字体大小进行比例调整 rem 经常被用于移动端响应式的布局，原理是通过 媒体查询 或 flexible.js，在屏幕尺寸发生变化时，改变 html 元素的字体大小。也可以和 vw、vh 配合使用，用 vw 设置 html 根元素字体大小，当窗口大小改变时实现自适应改变字体大小。\n3.16 清除浮动 结尾插入空标签或 br，添加 clear: both 父级盒子定义 overflow: hidden 父级盒子 display: table after 伪元素清除浮动 1 2 3 4 5 6 7 8 9 10 11 12 .clearfix:after { content: \u0026#34;\u0026#34;; display: block; height: 0; clear: both; visibility: hidden; } /* IE6、7 专有 */ .clearfix { *zoom: 1; } before 和 after 双伪元素清除浮动 1 2 3 4 5 6 7 8 9 10 11 12 13 .clearfix:before, .clearfix:after { content: \u0026#34;\u0026#34;; display: table; } .clearfix:after { clear: both; } .clearfix { *zoom: 1; } 3.17 元素消失 visibility: hidden opacity: 0 display: none 前两个元素存在但不显示，后面这个元素不渲染，不保留位置\n3.18 position 属性值有 static | relative | fixed | absolute | sticky | inherit\nstatic 和 relative 不脱离文档流，relative 用于定位偏移的位置也作为空间保留\nfixed 和 absolute 脱离文档流，absolute 用于定位父元素不受影响，fixed 是相对于浏览器窗口进行定位\n4. Vue 4.1 MVC 和 MVVM MVC 在 Controller 中响应用户对 View 的事件，Controller 调用 Model 的接口对数据进行操作，一旦 Model 发生变化 Model 就通知相关视图进行更新\nModel：数据和数据的处理方法 View：视图，负责对数据的展示 Controller：定义界面对用户输入的响应方式，连接模型和视图，用于控制应用程序的流程，处理用户的行为和数据上的改变 MVVM mvvm 把 view 和 model 的同步逻辑自动化，只需要告诉 view 的显示内容与 model 哪一部分对应即可。采用双向绑定。\nModel：数据和数据的处理方法 View：视图，负责对数据的展示 ViewModel：View 的变动，自动反映在 ViewModel 4.2 生命周期 Vue 有完整的生命周期，创建 -\u0026gt; 挂载 -\u0026gt; 更新 -\u0026gt; 销毁\nbeforeCreated\n开始创建数据，只有默认的生命周期钩子和默认事件，data 和 methods 还没有初始化 Created\ndata 有了，可以访问数据和方法，但没有挂载到 DOM，可以操作数据 beforeMount\n挂载之前，编译好了，但还没有挂载到页面上 Mounted\n到此创建完成了，可以进行 DOM 操作了 beforeUpdate\ndata 中数据已经更新了，但还没有更新到页面上，页面上还是旧的数据 Updated\n页面上的数据被更新了，页面和 data 中数据一致了 beforeDestroy\n销毁之前，适合销毁定时器等 Destroyed\n所有的数据、方法、过滤器、指令都不可用了，组件已经被销毁了 4.3 双向绑定 Object.defineProperty Object.defineProperty 进行数据劫持，遍历所有的属性给它们增加 getter 和 setter，组件的 data 发生变化时，将变化发布给订阅者，订阅者收到消息后进行处理\n缺点：\n无法监听数组通过下标改变对应数据 无法对新增加或删除的属性进行监听，需要使用 Vue.set() 一次性递归到底开销很大 Proxy 使用 ES6 提供的 Proxy 进行数据拦截，劫持整个对象，然后返回一个新对象\n解决无法监听新增属性或删除属性的响应式问题、解决无法监听数组长度和 index 变化问题。\n4.4 Vue3新特性 proxy 代替 Object.defineProperty 优化 diff 算法 生命周期不同了 Vue3 使用组合式 API 支持 TS 4.5 路由 history 美观但兼容性略差，部署上线可能会出现 404 问题。\n解决方法：使用 node 的 connect-history 中间件\nhash 哈希模式 # 后面的路径不发送给服务器，不太美观，有可能被 APP 标记为不合法，但兼容性好。\n4.6 路由守卫 作用：保护路由的安全，权限问题\n全局路由守卫 分为beforeEach、beforeResolve、afterEach\n使用：全局前置路由守卫beforeEach 进行权限校验\n独享路由守卫 只有前置守卫beforeEnter，是在路由配置页面单独给路由配置的一个守卫\n使用：不同的路由重用守卫，beforeEnter 守卫只在进入路由时触发\n组件内路由守卫 分为进入守卫和离开守卫beforeRouteEnter、beforeRouteLeave、beforeRouteUpdate\n使用：\nbeforeRouteLeave：离开页面时弹出提示窗口，清除当前组件中的定时器等；关闭页面时, 将公用信息保存到 session 或 Vuex 中；当前页面中有未关闭的窗口或未保存的内容阻止页面跳转 beforeRouteUpdate：动态路由跳转 4.7 Vuex 用于集中式管理数据，一般用于大中型应用\nstate：记录数据状态 getters：获取数据，可以根据 state 中的数据进行过滤派生出一些新的数据 action：进行异步操作 mutations：唯一可以改变 state 中数据的方法 module：如果数据较多可以分模块 4.8 nextTick Vue在更新数据时是异步执行的，data 中数据更新了但页面还没来得及更新，所以如果立刻获取 DOM，获取到的是还没有更新的 DOM，nextTick 就是等数据更新之后再进行 DOM 操作。本质是返回一个 Promise\n4.9 Diff算法 Diff 算法用来找出虚拟 DOM 中被改变的部分，然后针对原生 DOM 进行渲染，不用改变所有节点重新渲染整个页面\n比较方式\n同层比较：两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动 DOM 元素。所以 Virtual DOM 只会对同一个层级的元素进行对比，这样算法复杂度就可以达到 O(n)。 深度优先：在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记。在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 4.10 组件间通信 父传子：props 子传父：$emit, $on 任意组件间 vuex eventbus：使用方法是创建一个新的Vue实例，需要通信的组件都引入该Vue实例，传递数据的组件使用 event.$emit('名称',参数) 发送数据，接收数据的组件使用 event.$on('名称',方法) 接收数据 订阅发布模式 4.11 keep-alive 用 \u0026lt;keep-alive\u0026gt; 标签对需要缓存的组件进行包裹，保存内存中组件的状态，进行缓存，防止重新加载 DOM，减少加载时间，提高性能。\n多了两个生命周期：activated、deactivated，分别在进入和退出时触发。\n属性：\ninclude：缓存包含哪些组件 exclude：缓存不包含哪些组件 max：最多保存的组件数 4.12 v-if 和 v-show v-if 一开始不渲染，不在 DOM 树中，节点要显示出来才开始渲染，渲染一次消耗很大 v-show 一开始渲染好了只是不显示，适用于隐藏显示操作频繁的情况 4.13 为什么 data 不能是一个对象而是一个匿名函数？ JS 中对象是引用类型的数据，而在 Vue 的组件中，我们更多考虑的是组件的复用，所以每个 data 都要有自己独立的存储空间，这样组件之间才不会相互干扰。所以组件中要写成函数的形式，数据以函数的返回值定义，这样每次复用组件的时候就会返回新的 data。\n4.14 为什么 v-for 和 v-if 不要一起使用？ v-for 的优先级比 v-if 更高，如果放在一起使用，就算只需要渲染一小部分 v-if，每次 v-for 的计算也都会执行一遍所有的 v-if，造成不必要的计算，影响性能。\n5. Webpack 入口和出口 配置入口和出口文件\n1 2 3 4 5 6 7 8 9 var path =require(\u0026#39;path\u0026#39;) module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;main.js\u0026#39; }, }; 多个入口文件的配置\n多 -\u0026gt; 一\n1 2 3 4 5 6 7 8 var path =require(\u0026#39;path\u0026#39;) module.exports = { entry: [\u0026#39;./src/a.js\u0026#39;, \u0026#39;./src/b.js\u0026#39;], output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;main.js\u0026#39; }, }; 多 -\u0026gt; 多\n1 2 3 4 5 6 7 8 9 10 var path =require(\u0026#39;path\u0026#39;) module.exports = { entry: { a: \u0026#39;./src/a.js\u0026#39;, b: \u0026#39;./src/b.js\u0026#39; }, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), }, }; loader loader 让 webpack 可以处理除了 js 文件和 JSON 文件以外的其他类型的文件，将它们转换为有效模块\nloader 有两个属性：\ntest 识别出需要进行转换的文件 use 定义在进行转换时用哪个 loader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var path =require(\u0026#39;path\u0026#39;) module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;main.js\u0026#39; }, module: { rules: [{ test: /\\.txt\u0026amp;/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;] }] } }; 插件 plugin html-webpack-plugin\n1 2 3 4 5 6 7 8 9 var HTMLWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) module.exports = { plugins: [ new HTMLWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39;, filename: \u0026#39;index.html\u0026#39; }) ] } 6. 数据结构 6.1 常用的数据结构类型 参考\n数组、栈、堆、队列、链表、散列表、树、图\n6.2 二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function(nums, target) { let left = 0; let right = nums.length-1; while(left \u0026lt;= right) { let mid = left+((right-left) \u0026gt;\u0026gt; 1); if (nums[mid] === target) return mid; else if (nums[mid] \u0026gt; target) { right = mid-1; } else if (nums[mid] \u0026lt; target) { left = mid+1; } } return -1; }; 6.3 排序 冒泡排序 从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 1 的位置。\n1 2 3 4 5 6 7 8 9 10 11 12 function bubble(arr) { for(let i = 0; i \u0026lt; arr.length - 1; i++) { for(let j = 0; j \u0026lt; arr.length; j++) { if(arr[j] \u0026gt; arr[j+1]) { let tmp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = tmp; } } } return arr; } 冒泡每次只关注一个元素，两次循环，平均时间复杂度 \\( O(n^2) \\)，空间复杂度 \\( O(1) \\)，该算法是稳定的。\n插入排序 插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 function insertion(arr) { for(let i = 1; i \u0026lt; arr.length; i++) { for(let j = i-1; j \u0026gt;= 0; j--) { if(arr[j] \u0026gt; arr[j+1]) { let tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; } } } return arr; } 直接插入排序是稳定的，平均时间复杂度 \\( O(n^2) \\)，空间复杂度 \\( O(1) \\)\n选择排序 选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作。\n1 2 3 4 5 6 7 8 9 10 11 12 function selection(arr) { for(let i = 0; i \u0026lt; arr.length; i++) { let minIndex = i; for(let j = i+1; j \u0026lt; arr.length; j++) { minIndex = arr[j] \u0026lt; arr[minIndex] ? j : minIndex; } let tmp = arr[minIndex]; arr[minIndex] = arr[j]; arr[j] = tmp; } return arr; } 直接选择排序不稳定，平均时间复杂度 \\( O(n^2) \\)，空间复杂度 \\( O(1) \\)\n归并排序 归并排序的原理如下：递归的将数组两两分开直到最多包含两个元素，如果为奇数会有一组只有一个元素，分别排序，然后将数组排序合并再排序，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function sort(arr) { mergeSort(arr, 0, arr.length - 1); return arr; } function mergeSort(arr, l, r) { // 递归结束条件 if(l === r) return; let mid = parseInt(left + ((right - left) \u0026gt;\u0026gt; 1)); mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); let tmp = []; let i = 0; let p1 = l; let p2 = mid + 1; // 将排序好的数组放入 tmp while(p1 \u0026lt;= mid \u0026amp;\u0026amp; p2 \u0026lt;= r) { tmp[i++] = arr[p1] \u0026lt; arr[p2] ? arr[p1++] : arr[p2++]; } while(p1 \u0026lt;= mid) { tmp[i++] = arr[p1++]; } while(p2 \u0026lt;= r) { tmp[i++] = arr[p2++]; } for(let i = 0; i \u0026lt; tmp.length; i++) { arr[l + i] = tmp[i]; } return arr; } 快排 随机选取一个数组中的值作为基准值，取值与基准值对比大小，比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function sort(arr) { quickSort(arr, 0, arr.length - 1); return arr; } function quickSort(arr, l, r) { // 结束条件 if(l \u0026gt; r) return; // 存储基准数 let tmp = arr[l]; let i = l; let j = r; while(i \u0026lt; j) { // 从右边开始寻找 while(arr[j] \u0026gt;= tmp \u0026amp;\u0026amp; i \u0026lt; j) { j--; } arr[i] = arr[j]; while(arr[i] \u0026lt;= tmp \u0026amp;\u0026amp; i \u0026lt; j) { i++; } arr[j] = arr[i]; } arr[i] = tmp; quickSort(arr, l, i-1); quickSort(arr, i+1, r); } 几种排序方法复杂度和稳定性比较 排序方法 平均时间复杂度 空间复杂度 稳定性 冒泡排序 \\( O(n^2) \\) \\( O(1) \\) 稳定 直接插入排序 \\( O(n^2) \\) \\( O(1) \\) 稳定 直接选择排序 \\( O(n^2) \\) \\( O(1) \\) 不稳定 快速排序 \\( O(nlogn) \\) \\( O(nlogn) \\) 不稳定 归并排序 \\( O(nlogn) \\) \\( O(n) \\) 稳定 ","permalink":"https://oooldgreen.github.io/posts/frontend/interview-practice/","summary":"\u003cp\u003e方便反复诵读复习\u003c/p\u003e","title":"期末知识点复习"},{"content":"穷游小项目跟练第二天。发现这虽然只是个随便练手的小项目，但是真的能练到很多理论上看过但没用过的功能（对我这种没有实战经验的小菜鸡来说）。\n制作n宫格图片 这是插在首页 Home 的轮播图下面的。\n创建组件并布局 这步主要是用 list 做出一个 n 宫格，这个 n 由后台请求回来的图片数决定。假设一排 5 张图片，所以图片都是 5 的倍数（练习里就是有 20 张图片）。\n因此，写样式时用 flex 布局，先准备一个容器，规定好宽度，其中每一个 li 宽度为 20%，并用绝对定位定小标题的位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 .container { width: 1200px; margin: 0 auto; margin-top: 30px; } .list { display: flex; flex-wrap: wrap; } .list li { position: relative; box-sizing: border-box; width: 20%; } .list span { position: absolute; right: 20px; bottom: 0px; } 获取数据并渲染 在首页组件 Home 获取图片数据，created 钩子里获取第一页图片，还要写一个根据页码变化获取图片。\n在 data 中准备好请求回来的数据的容器 list: []，以及总页数 total\n在 methods 中写请求的公共方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Home.vue getBlueberry(pageNum) { this.$api.getBlueberry({ blueBerryjam_id: pageNum }).then((res) =\u0026gt; { // console.log(res.data) if (res.status === 200) { this.list = res.data.blueBerryJam; this.total = res.data.maxPage; } else { return this.$message.error(\u0026#39;获取数据失败:(\u0026#39;) } }) } created 钩子里就直接写请求第一页\n1 2 3 4 // Home.vue created: { this.getBlueberry(1) } 通过 props 父传子把请求回来的 list 和 总页数 total 传递给 n 宫格子组件：\n1 2 \u0026lt;!-- Home.vue --\u0026gt; \u0026lt;Blueberry :list=\u0026#34;list\u0026#34; :total=\u0026#34;total\u0026#34;/\u0026gt; 在 n 宫格子组件中，用 v-for 遍历图片创建 li 列表\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- Blueberry.vue --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in list\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;item.img\u0026#34; :alt=\u0026#34;item.title\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{item.title}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 根据页码变化获取图片 页码存储在 vuex 中，在 watch 中监听页码的变化：\n1 2 3 4 5 \u0026#39;$store.state.pageNum\u0026#39;(newPageNum) { // console.log(newPageNum) // 页码改变重新请求蓝莓酱页码 this.getBlueberry(newPageNum) } 换页回到顶部 在 watch 中监听页码的变化，一旦变化就用 scrollTop\n1 document.documentElement.scrollTop = 500 + \u0026#39;px\u0026#39;; 二次封装分页组件 创建组件 获取 element-ui 本身的分页\n1 2 3 4 5 6 \u0026lt;el-pagination background layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;1000\u0026#34; \u0026gt; \u0026lt;/el-pagination\u0026gt; 在 /components/ 文件夹中建立自己的分页组件\n1 2 3 4 5 6 7 8 \u0026lt;el-pagination background layout=\u0026#34;total, prev, pager, next, jumper\u0026#34; :total=\u0026#34;total\u0026#34; :pageSize=\u0026#34;pageSize\u0026#34; @current-change=\u0026#34;pageChange\u0026#34; \u0026gt; \u0026lt;/el-pagination\u0026gt; 配置参数和方法 在 props 中设置 total 总页数 和 pageSize 每页数据个数都可以改变，但是都要设定类型为数字，且需要设置默认值，这样即使没有数据也不会不显示\n1 2 3 4 5 6 7 8 9 10 props: { total: { type: Number, default: 100 }, pageSize: { type: Number, default: 10 } } 在 methods 中定义监听页码改变的方法\n1 2 3 4 5 6 methods: { pageChange(pageNum) { // 只传输页码数据，不请求数据 this.$store.commit(\u0026#39;getPageNum\u0026#39;, pageNum) } } 我直接把页码数据 pageNum 存储在了 Vuex 中，这样需要在需要用到页码的组件中监听 vuex 中页码的变化（上面写过的代码就不再写一遍了）。其实只要能传递给需要用的组件就可以了，子传父可以用 $emit 。\n1 2 3 4 5 6 7 8 9 10 11 // store/index.js const store = new Vuex.Store({ state: { pageNum: 0 }, mutations: { getPageNum(state, payload) { state.pageNum = payload } } }) 使用 封装好之后，如果要使用，引入后直接传入需要的 pageSize 和 total 这两个变量即可\n1 \u0026lt;Pagination :total=\u0026#34;total\u0026#34; :pageSize=\u0026#34;pageSize\u0026#34;/\u0026gt; 新闻页面 新闻分栏 用 element-ui 的标签页 tabs 做分栏，其中有属性@tab-click=\u0026quot;handleClick\u0026quot;，点击切换的标签页 tab.index 返回一个数字，利用这个数字写 switch 用于请求不同分类的新闻内容，例如国内、国际、财经等。需要注意的是这个 tab.index 返回的看起来是一个数字，实际上是一个字符串，因此在写 switch 的时候需要给数字加上引号，我在这里报错了。 但是这个方法看起来仍然过于冗余，不知还有没有更好的方法。\n新闻页码切换 接着页码切换就可以用前面提取过的公共组件 MyPagination 了，但是这里因为我把页码数据存储在了 vuex 中，导致每个不同的标签页切换页码时页码数据的变化无法分开。因此我又在公共组件 MyPagination 中加入了子传父的数据传输方法，就可以在每次点击相应页码，触发 getChange 后获取到相应标签页对应页码的数据。\n1 this.$emit(\u0026#39;getChange\u0026#39;, pageNum) 1 \u0026lt;mypagination :total=\u0026#34;total\u0026#34; :pageSize=\u0026#34;pageSize\u0026#34; @getChange=\u0026#34;getYaowenChange\u0026#34;/\u0026gt; 轮播图 使用了 element-ui 的走马灯效果\n1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;banner\u0026#34;\u0026gt; \u0026lt;el-carousel height=\u0026#34;387px\u0026#34;\u0026gt; \u0026lt;el-carousel-item v-for=\u0026#34;item in bannerlist\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;item.img\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/el-carousel-item\u0026gt; \u0026lt;/el-carousel\u0026gt; \u0026lt;/div\u0026gt; 待解决问题：这里设置高度之后图片会变形，图片随着窗口自适应大小\n关键词搜索提示 设定：当搜索框中输入关键词后，下方出现下拉框信息\n方法：设置 watch 监听，出现 keyword 后，将 keyword 作为参数向后端发送请求，返回数据渲染至下拉框中\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 渲染下拉框 --\u0026gt; \u0026lt;div class=\u0026#34;show-data\u0026#34; v-show=\u0026#34;isShow\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;城市\u0026lt;/li\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in searchList\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;item.url\u0026#34;\u0026gt;{{item.cn_name}} \u0026lt;span class=\u0026#34;en_name\u0026#34;\u0026gt;{{item.en_name}}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;hotel\u0026#34; v-if=\u0026#34;item.count!==0\u0026#34;\u0026gt;{{item.count}}家酒店\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 // 监听关键词输入 watch: { input(keyword) { if(!keyword) { this.isShow = false; this.searchList = []; } else { //发送请求，显示下拉框 } } 样式设计 盒子宽度计算 一排有固定个数的盒子，每个盒子都相同，为了让每个盒子之间有固定的间距，可以给每个子盒子设置 margin-right: 20px，这样第四个盒子因为也要有右边距被挤到第二行去。 第一种解决方法是选择 每行最右边的盒子设置右边距为 0，这种方法比较麻烦。\n第二种解决方法可以给父盒子设置 margin-right: -20px;\n1 2 3 4 .container .today-recommend { margin-right: -20px; overflow: hidden; } 渐变背景 1 background-image: linear-gradient(90deg, rgba(40, 213, 164, .8), rgba(38, 208, 181, .8)); 鼠标悬浮放大图片 1 2 3 4 5 6 7 8 9 10 11 .img { overflow: hidden; } img { width: 275px; height: 185px; transition: all 1.5s; } img:hover { transform: scale(1.1); } 多出的字用省略号替代 强制一行显示\n1 2 3 text-overflow: ellipsis; white-space: nowrap; overflow: hidden; 强制两行显示，需加入注释 /*! autoprefixer: off */ 使 -webkit-box-orient: vertical 起作用\n1 2 3 4 5 6 overflow:hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; /*! autoprefixer: off */ -webkit-box-orient: vertical; 遇到的问题 公共组件重复使用的数据问题 因为把pageNum存进了vuex中，后面出大问题，一个组件里引用多次分页组件的时候页码就没法写了，会互相影响，因为只有一个值。解决方法上面已经写过了，就不赘述。\n图片请求 403 在 html 中加入\n1 \u0026lt;meta name=\u0026#39;referer\u0026#39; content=\u0026#39;no-referer\u0026#39;\u0026gt; ","permalink":"https://oooldgreen.github.io/posts/frontend/vue-budget-travel-day2/","summary":"\u003cp\u003e穷游小项目跟练第二天。发现这虽然只是个随便练手的小项目，但是真的能练到很多理论上看过但没用过的功能（对我这种没有实战经验的小菜鸡来说）。\u003c/p\u003e","title":"Budget Travel 项目记录 Day2"},{"content":"穷游小项目跟练第一天。\n创建vue项目 控制台方法\n创建项目： 1 vue create filename 启动项目： 1 2 cd filename npm run server vue ui方法\n打开vue-ui，直接进行创建和配置 配置路由拦截 配置路由前置守卫用于校验用户是否有登录权限。 先在路由界面配置meta判断是否需要权限\n1 meta: { isLogin: true } 再配置路由守卫进行判断，如果需要登录权限，则判断是否已经登陆，若没有登录跳转登录页面，否则放行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 路由拦截：路由前置守卫 router.beforeEach((to, from, next) =\u0026gt; { // 1.判断当前的路由是否需要登录 if (to.meta.isLogin) { // 2.判断当前的用户状态是否已登录 const token = \u0026#39;\u0026#39; if (token) { next() } else { next(\u0026#39;/login\u0026#39;) } } else { // 不需要登录 next() } }) 写根目录页面 引入element-ui 全局引入 在main.js中写入以下代码\n1 2 3 4 5 6 7 8 9 10 11 import Vue from \u0026#39;vue\u0026#39;; import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; Vue.use(ElementUI); new Vue({ el: \u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App) }); 按需导入 全局引入并不是最好的方法，我们可以使用按需引入来减小项目体积，优化项目。\n首先借助babel-plugin-component插件，在babel.config.js中写入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 module.exports = { \u0026#34;presets\u0026#34;: [ \u0026#34;@vue/app\u0026#34; ], \u0026#34;plugins\u0026#34;: [ [ \u0026#34;component\u0026#34;, { \u0026#34;libraryName\u0026#34;: \u0026#34;element-ui\u0026#34;, \u0026#34;styleLibraryName\u0026#34;: \u0026#34;theme-chalk\u0026#34; } ] ] } 接着开始部分引入。可以单独写一个element.js来做引入，引入单独的组件，例如home页面写了一个菜单栏和登录按钮，引入如下。以后需要什么组件也都要引入。\n1 2 3 4 5 6 7 8 9 10 11 // element.js import Vue from \u0026#39;vue\u0026#39; import { Button, Menu, MenuItem } from \u0026#39;element-ui\u0026#39; Vue.use(Button) Vue.use(Menu) Vue.use(MenuItem) 最后在main.js中引入element.js文件。\n1 2 // main.js import \u0026#39;./plugins/element\u0026#39; 菜单栏 把myMenu作为布局layout.vue的一个组件，在myMenu.vue中用el-menu做菜单栏。\n菜单栏页面内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!-- myMenu.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 导航栏 --\u0026gt; \u0026lt;div class=\u0026#34;nav\u0026#34;\u0026gt; \u0026lt;el-menu :default-active=\u0026#34;$route.path\u0026#34; class=\u0026#34;el-menu-demo\u0026#34; mode=\u0026#34;horizontal\u0026#34; @select=\u0026#34;selectMenu\u0026#34; \u0026gt; \u0026lt;el-menu-item index=\u0026#34;/\u0026#34;\u0026gt;首页\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;/news\u0026#34;\u0026gt;新闻\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;/about\u0026#34;\u0026gt;我的\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;/travel\u0026#34;\u0026gt;旅游\u0026lt;/el-menu-item\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在布局组件中引入\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- layout.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;myMenu/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import myMenu from \u0026#39;../components/MyMenu.vue\u0026#39; export default { components: { myMenu } } \u0026lt;/script\u0026gt; 登录按钮（需要先写好登录页面） 描述：点击页面右上角登录按钮跳转登录页面，登录成功跳回首页，右上角按钮显示退出登录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 导航右侧内容 --\u0026gt; \u0026lt;div class=\u0026#34;nav-right\u0026#34;\u0026gt; \u0026lt;!-- 没登录显示登录按钮，已登录显示退出登录template --\u0026gt; \u0026lt;el-button v-if=\u0026#34;!userInfo.username\u0026#34; size=\u0026#34;small\u0026#34; @click=\u0026#34;login\u0026#34;\u0026gt;登录\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { login() { this.$router.push(\u0026#39;/login\u0026#39;) } } }; \u0026lt;/script\u0026gt; 登出按钮 描述：点击退出登录清空vuex中和存储在本地的用户信息，跳回首页。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 导航右侧内容 --\u0026gt; \u0026lt;div class=\u0026#34;nav-right\u0026#34;\u0026gt; \u0026lt;!-- 没登录显示登录按钮，已登录显示退出登录template --\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;span\u0026gt;欢迎你，\u0026#34;{{userInfo.username}}\u0026#34;\u0026lt;/span\u0026gt; \u0026lt;el-button size=\u0026#34;small\u0026#34; @click=\u0026#34;logout\u0026#34;\u0026gt;退出登录\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapState, mapMutations } from \u0026#39;vuex\u0026#39; export default { methods: { ...mapMutations(\u0026#39;loginModule\u0026#39;, [\u0026#39;clearUser\u0026#39;]), logout() { // 清空vuex和本地用户数据 this.clearUser(), localStorage.removeItem(\u0026#39;userInfo\u0026#39;) // 跳转路由 this.$router.push(\u0026#39;/\u0026#39;) } }, computed: { ...mapState(\u0026#39;loginModule\u0026#39;, [\u0026#39;userInfo\u0026#39;]) } }; \u0026lt;/script\u0026gt; 写登录页面 创建一个简易的登录接口 第一步：安装express和jwt\n1 npm i express -S 第二步：在根目录下创建服务器文件夹server\n第三步：在server中创建index.js\n引入express和cors 1 2 3 4 5 6 // 引入express和cors const express = require(\u0026#39;express\u0026#39;) const app = express() const cors = require(\u0026#39;cors\u0026#39;) app.use(cors()) 开启服务端口 1 2 3 app.listener(8888, () =\u0026gt; { console.log(\u0026#39;server running at http://127.0.0.1:8888\u0026#39;) }) 创建登录接口 1 2 3 4 5 6 7 8 9 10 11 app.get(\u0026#39;/login\u0026#39;, (req, res) =\u0026gt; { let user = req.query.username; let pwd = req.query.pwd; res.send({ info: \u0026#39;success\u0026#39;, status: 200, data: { user, pwd } }) 第四步：打开server文件夹的终端窗口，nodemon启动（安装nodemon可以实时更新不用一直关闭重启）\n生成token 第一步：安装jwt\n1 npm i jsonwebtoken -S 第二步：自定义密钥？并引入\n1 2 3 4 5 6 7 // secretKey.js module.exports = { secretKey: \u0026#39;20223jiayou\u0026#39; } // index.js 引入密钥 const secret = require(\u0026#39;./secretkey\u0026#39;) 第三步：生成token\n语法：jwt.sign('数据','密钥','过期时间')\n过期时间: { expiresIn: '1day/1h/10' } 默认单位为秒\n1 2 3 4 5 // 生成token标识 const jwt = require(\u0026#39;jsonwebtoken\u0026#39;) const token = jwt.sign({ user, id: xxx }, secret.secretKey, { expiresIn: 20 }) res.send(token) 存储用户数据（vuex和localStorage） vuex存储 在store中设置token和清空用户信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 state: { userInfo: { username: \u0026#39;\u0026#39;, token: null } }, mutations: { // 设置token setUser(state, payload) { state.userInfo = payload; }, // 清空用户信息 clearUser(state) { state.userInfo = { username: \u0026#39;\u0026#39;, token: null } } } 在Login.vue配置存储一个对象包含token和用户名，存储在vuex中\n1 2 3 4 5 6 7 //Login.vue // 存储数据并用vuex共享资源 let obj = { token: res.data.token, username: jwt(res.data.token).user } this.$store.commit(\u0026#39;setUser\u0026#39;, obj) 存储到localStorage 1 2 // Login.vue localStorage.setItem(\u0026#39;userInfo\u0026#39;, JSON.stringify(obj)) //对象需要转化成字符串 遇到的问题 beforeEach is not a function 使用导航守卫时页面报错了：beforeEach is not a function\n检查后发现我直接daochuleexport default new Router({...})，然后写的beforeEach\n应该先new一个实例，给声明的路由实例添加方法才对：const router = new Router({ routes })\nvuex版本问题 用的vue2但是vuex装的是4，报错，检查this.$store输出为undefined\n改成vue2对应的vuex3： npm install vuex@3\n然后babel报错：npm install @babel/core @babel/preset-env\n报错Uncaught (in promise) NavigationDuplicated 发现是vue-router跳转到自己的时候会报错，查看我的vue-router版本已经是3.5.1，所以没有按网上说的装3.0版本，最后解决方法是在main.js中加入以下代码\n1 2 3 4 5 6 7 import Router from \u0026#39;vue-router\u0026#39; Vue.use(Router) const originalPush = Router.prototype.push Router.prototype.push = function push(location) { return originalPush.call(this, location).catch(err =\u0026gt; err) } ","permalink":"https://oooldgreen.github.io/posts/frontend/vue-budget-travel-day1/","summary":"\u003cp\u003e穷游小项目跟练第一天。\u003c/p\u003e","title":"Budget Travel 项目记录 Day1"},{"content":"一直想练手但是拖了好久的项目。\n此文档为vue2项目elm的练手记录，从前端页面开始做起。\n配置 mongodb配置 开启mongodb mongodb的bin用终端打开\n./mongod --dbpath /usr/local/MongoDB/data/db --logpath /usr/local/MongoDB/log/mongo.log\nTip：如果发生错误是因为上一次没有正确的关闭mongodb，需要把.lock文件删除，再重启\n连接navicat 若果第一步开启好了，点击左下角的test很快就会提示测试连接成功，直接确定就好了\n导入数据库 对于.metadata.json文件： mongoimport -d elm_db -c activities --file activities.metadata.json\n对于.bson文件： mongorestore -d elm_db -c activities activities.bson\n在navicat中刷新就可以看到数据被导入了\n正确的关闭mongodb 使用Ctrl + C\nWarning：千万不能使用kill -9 \u0026lt;pid\u0026gt;,因为MongoDB使用mmap方式进行数据文件管理，也就是说写操作基本是在内存中进行，写操作会被每隔60秒(syncdelay设定)的flush到磁盘里。如果在这60秒内flush处于停止事情我们进行kill -9那么从上次flush之后的写入数据将会全部丢失。\n其他mongodb操作 当前数据库：db\n展示所有数据库：show dbs\n切换到admin数据库：use admin\nEslint配置 关闭校验 在根目录下创建vue.config.js\n1 2 3 4 moduel.export = { // 关闭eslint lintOnSave: false } 检验规则配置 1 2 3 4 5 6 7 8 9 // .eslintrc.js rules: { // 禁止空格报错检查 \u0026#39;generator-star-spacing\u0026#39; : \u0026#39;off\u0026#39;, // 不校验组件名 \u0026#39;vue/multi-word-component-names\u0026#39;: \u0026#39;off\u0026#39;, // 没用过的不报错 \u0026#39;no-use-before-define\u0026#39;: \u0026#39;off\u0026#39; } 路由配置 创建Home.vue，在路由js中引入并配置：\n1 2 3 4 5 6 7 8 9 10 11 const routes = [ { path: \u0026#39;/home\u0026#39;, name: \u0026#39;home\u0026#39;, component: Home, meta:{ // 需要被缓存 keepAlive: true } } ] 引入 SCSS 安装依赖包，出错就在后面添加 --legacy-peer-deps\n1 npm i node-sass sass-loader style-loader -D vue-cli 会自动配置好，正常创建.scss文件就可以了。\n引入使用 SVG 雪碧图 安装依赖包 svgo 和 svg-sprite-loader 创建 svg.vue 1 2 3 4 5 6 7 \u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;symbol viewBox=\u0026#34;0 0 1024 1024\u0026#34; id=\u0026#34;arrow-right\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M716.298 417.341l-.01.01L307.702 7.23l-94.295 94.649 408.591 410.117-408.591 410.137 94.295 94.639 502.891-504.76z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/symbol\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; 全局引入 1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;svg-icon\u0026gt;\u0026lt;/svg-icon\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import svgIcon from \u0026#39;./components/common/svg.vue\u0026#39;; export default { components: { svgIcon } } \u0026lt;/script\u0026gt; 使用 1 2 3 \u0026lt;svg class=\u0026#34;arrow_right\u0026#34;\u0026gt; \u0026lt;use xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; xlink:href=\u0026#34;#arrow-right\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; 插槽 slot 在父组件中写入想要插在子组件中的内容，在子组件中用 slot 占好位置，编译的时候就会将父组件中写好的内容根据 slot 的位置注入到子组件中。\n当需要插入多个 slot 时，可以用 name 来指定插入的是哪一个 slot。\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- Home.vue --\u0026gt; \u0026lt;HeaderTop\u0026gt; \u0026lt;span class=\u0026#34;logo\u0026#34; slot=\u0026#34;logo\u0026#34;\u0026gt;ele.me\u0026lt;/span\u0026gt; \u0026lt;/HeaderTop\u0026gt; \u0026lt;!-- head.vue --\u0026gt; \u0026lt;header\u0026gt; \u0026lt;slot name=\u0026#34;logo\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/header\u0026gt; 利用 slot 就可以在 head 组件里灵活的根据不同需要组成不同的 header 了。\n使用 Fetch 发送请求 参考 MDN\n都是跨网络获取资源的方法，以前只学过 ajax，项目里用过 axios，今天来了解一下 fetch。\nfetch 也是返回一个 Promise，但是被拒绝以后不会被标记为 reject，而是将 resolve 的返回值 ok 标记为 false，只有网络故障和请求被阻止这两种情况会标记 reject。\n（1）fetch 的简单使用：\n1 2 3 4 5 6 7 fetch(\u0026#39;https://xxx.com\u0026#39;, { // 如果跨域发送 cookie credentials: \u0026#39;include\u0026#39; }).then( // 进行数据操作 response =\u0026gt; response.json() ).then(data =\u0026gt; console.log(data)) （2）带有第二个参数，传递 data\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 async function postData(url = \u0026#39;\u0026#39;, data = {}) { credentials: \u0026#39;include\u0026#39;, // include/same-origin/omit mode: \u0026#39;cors\u0026#39;, // cors/no-cors/same-origin cache: \u0026#39;default\u0026#39; // default/no-cache/reload/force-cache/only-if-cached // 配置 headers headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; // \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, body: JSON.stringify(data) // 数据类型和 content-type 相匹配 // 解析 JSON 字符串 return response.json() } postData(\u0026#39;https://example.com/answer\u0026#39;, { answer: 42 }).then(data =\u0026gt; { console.log(data) }) 在本项目中发送请求需要带有 data。创建两个文件，一个对不同请求类型进行一些处理，另一个负责发送 fetch 请求。获得当前城市定位需要的是 GET 请求，因此先处理 GET 请求内容 —— 网址拼接字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // fetch.js // 配置 fetch // 设置baseUrl，data，默认类型和方法 export default async (url = \u0026#39;https://elm.cangdu.org\u0026#39;, data = {}, type = \u0026#39;GET\u0026#39;, method = \u0026#39;fetch\u0026#39;) =\u0026gt; { // 转换所有的请求为大写 type = type.toUpperCase() // 判断请求类型 // 如果请求类型为 GET if(type == \u0026#39;GET\u0026#39;) { let dataStr = \u0026#39;\u0026#39; //拼接字符串 Object.keys(data).forEach(key =\u0026gt; { dataStr = dataStr + key + \u0026#39;=\u0026#39; + data[key] + \u0026#39;\u0026amp;\u0026#39; }) if(dataStr !== \u0026#39;\u0026#39;) { // 切除最后多余的 \u0026amp; 符号 dataStr = dataStr.substring(0, dataStr.lastIndexOf(\u0026#39;\u0026amp;\u0026#39;)) url = url + \u0026#39;?\u0026#39; + dataStr } } if (window.fetch \u0026amp;\u0026amp; method === \u0026#39;fetch\u0026#39;) { let requestConfig = { credentials: \u0026#39;include\u0026#39;, method: type, headers: { \u0026#39;Accept\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, mode: \u0026#39;cors\u0026#39;, cache: \u0026#39;force-cache\u0026#39; } if (type === \u0026#39;POST\u0026#39;) { Object.defineProperty(requestConfig, \u0026#39;body\u0026#39;, { value: JSON.stringify(data) }) } // 捕获错误 try { const response = await fetch(url, requestConfig) const responseJson = await response.json() return responseJson } catch (error) { throw new Error(error) } } else { return new Promise((resolve, reject) =\u0026gt; { let requestObj if (window.XMLHttpRequest) { requestObj = new XMLHttpRequest() } else { requestObj = new ActiveXObject } let sendData = \u0026#39;\u0026#39; if(type === \u0026#39;POST\u0026#39;) { sendData = JSON.stringify(data) } requestObj.open(type, url, true) requestObj.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;) requestObj.onreadystatechange = () =\u0026gt; { if (requestObj.readyState === 4) { if (requestObj.status === 200) { let obj = requestObj.response if (typeof obj !== \u0026#39;object\u0026#39;) { obj = JSON.parse(obj) } resolve(obj) } } else { reject(requestObj) } } }) } } 1 2 3 4 5 6 7 8 9 10 // getData.js // 进行 fetch 请求 // 请求定位地址 export const cityGuess = () =\u0026gt; fetch(\u0026#39;/v1/cities\u0026#39;, { type: \u0026#39;guess\u0026#39; }) // 组件中使用 cityGuess().then(data =\u0026gt; {console.log(data)}) v-for 遍历 遍历数组 1 2 3 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in list\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 还可以遍历对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key, index) in list\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt;{{key}} --- {{value}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; data() { return { list: { // key: value A: xx, B: [xx, xx, ...] } } } \u0026lt;/script\u0026gt; 城市按字母排序 根绝对象 key 值进行排序，这种情况可以使用计算属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; export default { computed: { sortGroupCity() { const sortObj = {} Object.keys(this.groupCity).sort().map(key =\u0026gt; { sortObj[key] = this.groupCity[key]; }) return sortObj } } } \u0026lt;/script\u0026gt; 目标功能 定位功能 ","permalink":"https://oooldgreen.github.io/posts/frontend/vue2-elm-day1/","summary":"\u003cp\u003e一直想练手但是拖了好久的项目。\u003c/p\u003e","title":"Vue2 Elm 项目记录 Day1"},{"content":"从小到大都对属于自己的东西格外着迷，可能是骨子里的控制欲作祟吧，于是突发奇想地想要拥有属于自己的博客。\n就当是我在这动荡时代的自留地。\n这篇博客一共分为四个部分：hugo搭建个人博客，vercel部署博客，自定义域名，最后是一些有用的文档内容。\nHugo搭建 下载Hugo 参考官方文档\n方法一：二进制（MACOS） 进入Hugo Release 下载最新版本，解压缩（记得要下载extend版本） 把hugo文件放进/usr/local/bin 输入hugo version检查版本号，出现版本号，安装成功 方法二：Homebrew 或者更简单，如果你有homebrew，直接：\n1 brew install hugo 建立新网站 1 hugo new site quickstart 这句指令会生成一个名为quickstart的文件夹，如下图： quickstart文件夹 选择喜欢的主题 按照hugo的提示选择主题，我选择的主题是jane，具体步骤：\n直接下载压缩包解压 经过一个改名字的动作（需要把文件名称从hugo-theme-jane改为jane） 再把文件夹放在quitckstart \u0026gt; themes文件夹下，就阔以啦 接着我按照jane的说明文档copy了一些网站样例和默认设置： 1 2 cp -r themes/jane/exampleSite/content ./ cp themes/jane/exampleSite/config.toml ./ 当然，也可以创建自己的主题：\n1 hugo new theme \u0026lt;THEMENAME\u0026gt; 生成我的第一支博客 在我的博客文件夹下输入以下代码：\n1 hugo new posts/my-first-post.md Tips:\njane配置的博客目录在post，不同主题可能有细微差别\n名字一定要加后缀！起名字最好就是英文小写+短横线～\n部署 部署到Github 先有一个Github账号 进入github（此处可能需要🪜） 输入邮箱，点击Sign up for GitHub创建账号 然后登录就好啦 创建新的repository 点击右上角加号+ -\u0026gt; new repository 输入你的repository name，例如myblog 记得检查一下是否选择public（默认应该就是这个啦） 点击create repository创建仓库 把本地博客文件关联到这个仓库 这步按照GitHub创建仓库后的指示走就完全可以\n1 2 3 4 5 6 git init git status git add . git commit -m \u0026#34;start\u0026#34; git remote add origin git@github.com:OooldGreen/Hugo-Sources.git git push -u origin main 这里我设置了ssh代理，因为https拉取不到仓库，你懂的～ 具体怎么设置代理，我看的这篇：https://zhuanlan.zhihu.com/p/481574024\n通过Vercel生成网站 Vercel在这里，它方便快捷。 当然如果用github pages或者别的也可以～\n先用GitHub登录，进入DashBoard 点击Create a New Project 关联GitHub，导入myblog仓库，点击Deploy 出现Congratulations！就成功啦，进入DashBoard就可以点击进入自己的网站啦 自定义域名 如果你觉得自动生成的域名不够炫酷，还可以选择自定义域名。只要你有心，不花钱钱也是可以做到的哦（0v0）。我全程参考了necolas小站的教程😁\n如果想完成此步，需要准备两个网站：\n1. freenom租免费域名\n2. 管理域名的腾讯云\n选择你喜欢的域名 在搜索框中搜索域名是否可用 复制全部域名再搜索一遍 此时购物车+1，点击checkout 拥有时长选择12months，结账完事～ 页面记得留着，等会儿还得用\n在腾讯云配置 腾讯云需要实名验证，验证完之后进入“我的域名” 输入域名，进入DNS检测，检测会出问题，复制正确的配置 回到freenom粘贴配置 再回到腾讯云重新检测，这时就没有问题啦 在Vecel中配置 点击Settings -\u0026gt; Domains 输入你已经拥有的域名，点击add，默认选项即可 此时会显示域名不可用 在腾讯云中点击域名 -\u0026gt; 添加记录 按照提示vecel中的\u0026quot;type\u0026quot;, \u0026quot;name\u0026quot;, \u0026quot;value\u0026quot;进行配置，分别对应“记录类型”, “主机记录“, ”记录值“ 最后耐心等待一会儿就可以看到自己专属的域名啦～\nVercel问题修复 后来遇到一点问题： 换了PaperMod主题之后编译不成功，问题如下\n1 function \u0026#34;warnf\u0026#34; not defined 应该是Hugo版本问题，我指定了旧版的Hugo，在vercel -\u0026gt; Settings -\u0026gt; Enviroment Variables中填写\n1 2 NAME: HUGO_VERSION VALUE: 0.83.0 重新编译就可以了。\nHugo主题相关 PaperMod\u0026rsquo;s 百科\nJane Theme Preview\nhighlight.js 从higlight换成chroma（被官方文档蛊惑），又换回highlight，原因是看到chroma很多代码都没有高亮显示，强迫症实在难受，highlight怎么配置也没完全弄明白，用了cheat的方法把css样式表换了，还自定义了几个看不顺眼的高亮颜色。主题颜色也差不多是DIY，有看不顺眼的以后再改吧。\nhighlight.js样式预览\n一些常用配置\nmd相关 markdown语法（对不起我太菜了😭） ","permalink":"https://oooldgreen.github.io/posts/hugo-site/","summary":"\u003cp\u003e从小到大都对属于自己的东西格外着迷，可能是骨子里的控制欲作祟吧，于是突发奇想地想要拥有属于自己的博客。\u003c/p\u003e\n\u003cp\u003e就当是我在这动荡时代的自留地。\u003c/p\u003e\n\u003cp\u003e这篇博客一共分为四个部分：\u003ccode\u003ehugo\u003c/code\u003e搭建个人博客，\u003ccode\u003evercel\u003c/code\u003e部署博客，自定义域名，最后是一些有用的文档内容。\u003c/p\u003e","title":"关于配置博客"},{"content":"周末和朋友约了一起去吃一家希腊菜餐厅，超级远的\n但是很好吃，不辜负我公交快坐晕车 :)\n希腊酸奶，酸酸甜甜！ 不知道包了什么蔬菜的肉肠 米团子怎么也这么好吃呀😍 香香白酱意面，这个酱更好吃呀，好香好香 一盘牛扒～最爱吃肉！还有可爱小土豆🥔 ","permalink":"https://oooldgreen.github.io/posts/daily/angean-blue/","summary":"\u003cp\u003e周末和朋友约了一起去吃一家希腊菜餐厅，超级远的\u003c/p\u003e\n\u003cp\u003e但是很好吃，不辜负我公交快坐晕车 :)\u003c/p\u003e","title":"Angean Blue"},{"content":"今天是10月16日，终于动手用hugo搭建了自己的博客。希望在找不到工作的焦虑和毕业论文的压迫中找到一点成就感。\n作为一个记性不太好的人，这个博客想要用来记录前端学习的一切，以及一些温暖的日常。\n我必将用自己的方式冲破一切桎梏，到达我想去的地方。\n","permalink":"https://oooldgreen.github.io/posts/daily/my-first-post/","summary":"\u003cp\u003e今天是10月16日，终于动手用hugo搭建了自己的博客。希望在找不到工作的焦虑和毕业论文的压迫中找到一点成就感。\u003c/p\u003e\n\u003cp\u003e作为一个记性不太好的人，这个博客想要用来记录前端学习的一切，以及一些温暖的日常。\u003c/p\u003e","title":"My First Post"}]